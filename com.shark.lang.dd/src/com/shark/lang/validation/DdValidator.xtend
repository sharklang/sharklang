/*
 * generated by Xtext 2.21.0
 */
package com.shark.lang.validation

import com.google.inject.Inject
import com.google.inject.Provider
import com.shark.lang.dd.CheckExpression
import com.shark.lang.dd.Constraint
import com.shark.lang.dd.DataType
import com.shark.lang.dd.DdPackage
import com.shark.lang.dd.Entity
import com.shark.lang.dd.IdentifierExpression
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.resource.IContainer
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.ComposedChecks

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * It contains the following validation:
 * 	TODO test the global scope with several project and dependencies
 * 	- checks that entities are unique in the global scope 
 * 	- checks that the intrinsic check constrains group only refers attribute of the related entity
 * 	- checks that the check constraints are bool
 * 
 */
@ComposedChecks(validators=#[DdExpressionValidator, DdDeclarationValidator])

//TODO check numberUtil iCreatable and compare to exception management below 

class DdValidator extends AbstractDdValidator {

	@Inject
	IContainer.Manager containerManager;
	@Inject
	IResourceDescriptions resourceDescriptions
	@Inject
	Provider<XtextResourceSet> resourceSetProvider;
	@Inject
	DdExpressionValidator exprValidator;

	@Check
	def checkEntityGloballyUnique(Entity entity) {
		// visible containers is part of the global scope provider system
		val entity_description = resourceDescriptions.getResourceDescription(entity.eResource.URI)
		val visibleContainers = containerManager.getVisibleContainers(entity_description, resourceDescriptions)
		for (visibleContainer : visibleContainers) {
			for (_entity_description : visibleContainer.getExportedObjectsByType(DdPackage.Literals.ENTITY)) {
				val _entity = resourceSetProvider.get.getEObject(_entity_description.EObjectURI, true) as Entity
				if ((entity.eResource.URI != _entity.eResource.URI) && (entity.name == _entity.name)) {
					error('Entity duplication', entity, DdPackage.Literals.ENTITY__NAME)
				}
			}
		}
	}

	// check that when the contraint name has the same with # as an entity of same file, then it manages only the entity attributes or constants and literals
	// indeed these expressions will be checked at each time the object is created/changed
	@Check
	def checkAttributesInEntityConstraint(Constraint cstr) {
		val cstr_description = resourceDescriptions.getResourceDescription(cstr.eResource.URI)
		val container = containerManager.getContainer(cstr_description, resourceDescriptions)

		val cstrName = cstr.name.substring(1, cstr.name.length) // strip out # from constraint name
		// get list of all entities in this file and check each if name is same
		for (_entity_description : container.getExportedObjectsByType(DdPackage.Literals.ENTITY)) {
			val _entity = resourceSetProvider.get.getEObject(_entity_description.EObjectURI, true) as Entity
			if (cstrName == _entity.name) {
				// in that case we check the list of operands to verify that none goes outside of the entity scope
				for (CheckExpression chk : cstr.check.toList) {
					for (EObject eObj : chk.eAllContents.toIterable) {
						if (eObj instanceof IdentifierExpression) {
							val ident = eObj as IdentifierExpression
							val referredEntity = ident.value.eContainer as Entity
							if (referredEntity.name != cstrName) {
								error(
									"Invalid Entity check expression: it cannot use a reference to an attribute outside of the referred Entity here " +
										referredEntity.name + " is used, but allowed only are attributes from " +
										cstrName, ident, DdPackage.Literals.IDENTIFIER_EXPRESSION__VALUE)
							}
						}
					}
				}
			}
		}
	}

//check expression need to be of boolean type	
	@Check
	def checkCheckConstraintsAreBoolean(CheckExpression checkExpr) {
		var type = exprValidator.getExpressionType(checkExpr.expr)
		if (type.value != DataType.BOOL_VALUE) {
			error("Invalid Check Expression: expression should be of type Boolean", checkExpr,
				DdPackage.Literals.CHECK_EXPRESSION__EXPR)
		} else {
			if (exprValidator.isListExpression(checkExpr.expr)) {
				error(
					"ListExpression of Bool do not have an implicit bool value and cannot be used as a direct check constraint",
					checkExpr, DdPackage.Literals.CHECK_EXPRESSION__EXPR)
			}
		}

	}

} //end class

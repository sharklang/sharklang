/*
 * generated by Xtext 2.23.0
 */
package com.shark.lang.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class DdGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class DataModelFragmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.DataModelFragment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantsConstantParserRuleCall_0_0 = (RuleCall)cConstantsAssignment_0.eContents().get(0);
		private final Assignment cEntitiesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEntitiesEntityParserRuleCall_1_0 = (RuleCall)cEntitiesAssignment_1.eContents().get(0);
		private final Assignment cConstraintsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConstraintsConstraintParserRuleCall_2_0 = (RuleCall)cConstraintsAssignment_2.eContents().get(0);
		
		////no empty entity and so mandatory BEGIN/END structure
		////BEGIN / END added when there is an indent level change
		////EOL tokens are added after an indent constant or no indent and a new line
		////IDENT triggered after a Comment so generates EOL 
		////with such grammar, comment are controlled for metrics and positioning --> not free anywhere --> there and concise
		////TODO improve display of outline with name attribute
		////TODO document design and classes and some design decisions in the grammar as comments here
		////TODO test expressions interactively and build non passing JUNIT tests using excel random
		////TODO check cast date format
		////TODO check empty string const on like
		////TODO validation of cross entity checks if not 1-1
		////TODO customize error messages for parser and lexer: eg constant en maj
		////TODO do a first output
		////TODO update formatter
		////TODO semantic highlighting example, true / false in yellow and decl in bold
		////TODO add formats on top of checks to be used by like operator: 5A003a-"H" with positions. formats will be usable to split
		////TODO test date operations + 1*DAY... basing on the generator error management
		////TODO add min, max, avg
		////TODO ad validation of size vs. real constant or init value size, like wise for list size, decimal precision...
		////TODO move to github
		////TODO add content assist
		////TODO split into reusable grammar and create sd and sk languages
		////TODO implement math a bit more: implement the expression precision check and rounding routines
		////TODO in this context consider removing int and stick to general dec(n,0)?
		////TODO as for constant they need to be calculatable expressions at compile time so use groovy or other in 
		////Validation to evaluate it, but keep the expression in java as the java compiler will simplify then.
		////TODO check and neutralize useless comment associator
		////TODO check that all text is assigned
		////TODO change the outline view with several levels: summary pretty and full. the full lone would look like the 
		////ecore sample editor. editor read again the XtextRessource so normal that my boolean are not there. they would have to 
		////be persisted in hidden text... But core code generation maybe the in memory AST is the same as in validation
		////to test.
		//DataModelFragment:
		//	constants+=Constant*
		//	entities+=Entity*
		//	constraints+=Constraint*;
		@Override public ParserRule getRule() { return rule; }
		
		//constants+=Constant* entities+=Entity* constraints+=Constraint*
		public Group getGroup() { return cGroup; }
		
		//constants+=Constant*
		public Assignment getConstantsAssignment_0() { return cConstantsAssignment_0; }
		
		//Constant
		public RuleCall getConstantsConstantParserRuleCall_0_0() { return cConstantsConstantParserRuleCall_0_0; }
		
		//entities+=Entity*
		public Assignment getEntitiesAssignment_1() { return cEntitiesAssignment_1; }
		
		//Entity
		public RuleCall getEntitiesEntityParserRuleCall_1_0() { return cEntitiesEntityParserRuleCall_1_0; }
		
		//constraints+=Constraint*
		public Assignment getConstraintsAssignment_2() { return cConstraintsAssignment_2; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_2_0() { return cConstraintsConstraintParserRuleCall_2_0; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.Constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExtraAttrDescAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExtraAttrDescLineCommentParserRuleCall_0_0 = (RuleCall)cExtraAttrDescAssignment_0.eContents().get(0);
		private final Assignment cDataTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDataTypeDataTypeEnumRuleCall_1_0 = (RuleCall)cDataTypeAssignment_1.eContents().get(0);
		private final Assignment cAttributeSizeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributeSizeAttributeSizeParserRuleCall_2_0 = (RuleCall)cAttributeSizeAssignment_2.eContents().get(0);
		private final Assignment cArraySizeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArraySizeArraySizeParserRuleCall_3_0 = (RuleCall)cArraySizeAssignment_3.eContents().get(0);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameCSTIDTerminalRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cDefaultValueAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cDefaultValueSharkExpressionParserRuleCall_5_1_0 = (RuleCall)cDefaultValueAssignment_5_1.eContents().get(0);
		private final Assignment cAttrDescAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cAttrDescTrailCommentParserRuleCall_6_0 = (RuleCall)cAttrDescAssignment_6.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///////////////////////////
		////Statement 0: constants
		//Constant:
		//	extraAttrDesc+=LineComment*
		//	dataType=DataType
		//	attributeSize=AttributeSize?
		//	arraySize=ArraySize?
		//	name=CSTID ('=' defaultValue=SharkExpression) attrDesc=TrailComment EOL;
		@Override public ParserRule getRule() { return rule; }
		
		//extraAttrDesc+=LineComment* dataType=DataType attributeSize=AttributeSize? arraySize=ArraySize? name=CSTID ('='
		//defaultValue=SharkExpression) attrDesc=TrailComment EOL
		public Group getGroup() { return cGroup; }
		
		//extraAttrDesc+=LineComment*
		public Assignment getExtraAttrDescAssignment_0() { return cExtraAttrDescAssignment_0; }
		
		//LineComment
		public RuleCall getExtraAttrDescLineCommentParserRuleCall_0_0() { return cExtraAttrDescLineCommentParserRuleCall_0_0; }
		
		//dataType=DataType
		public Assignment getDataTypeAssignment_1() { return cDataTypeAssignment_1; }
		
		//DataType
		public RuleCall getDataTypeDataTypeEnumRuleCall_1_0() { return cDataTypeDataTypeEnumRuleCall_1_0; }
		
		//attributeSize=AttributeSize?
		public Assignment getAttributeSizeAssignment_2() { return cAttributeSizeAssignment_2; }
		
		//AttributeSize
		public RuleCall getAttributeSizeAttributeSizeParserRuleCall_2_0() { return cAttributeSizeAttributeSizeParserRuleCall_2_0; }
		
		//arraySize=ArraySize?
		public Assignment getArraySizeAssignment_3() { return cArraySizeAssignment_3; }
		
		//ArraySize
		public RuleCall getArraySizeArraySizeParserRuleCall_3_0() { return cArraySizeArraySizeParserRuleCall_3_0; }
		
		//name=CSTID
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }
		
		//CSTID
		public RuleCall getNameCSTIDTerminalRuleCall_4_0() { return cNameCSTIDTerminalRuleCall_4_0; }
		
		//('=' defaultValue=SharkExpression)
		public Group getGroup_5() { return cGroup_5; }
		
		//'='
		public Keyword getEqualsSignKeyword_5_0() { return cEqualsSignKeyword_5_0; }
		
		//defaultValue=SharkExpression
		public Assignment getDefaultValueAssignment_5_1() { return cDefaultValueAssignment_5_1; }
		
		//SharkExpression
		public RuleCall getDefaultValueSharkExpressionParserRuleCall_5_1_0() { return cDefaultValueSharkExpressionParserRuleCall_5_1_0; }
		
		//attrDesc=TrailComment
		public Assignment getAttrDescAssignment_6() { return cAttrDescAssignment_6; }
		
		//TrailComment
		public RuleCall getAttrDescTrailCommentParserRuleCall_6_0() { return cAttrDescTrailCommentParserRuleCall_6_0; }
		
		//EOL
		public RuleCall getEOLTerminalRuleCall_7() { return cEOLTerminalRuleCall_7; }
	}
	public class EntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.Entity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEntityDescLinesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEntityDescLinesLineCommentParserRuleCall_0_0 = (RuleCall)cEntityDescLinesAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameOBJIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExtendsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cExtendsEntityCrossReference_2_1_0 = (CrossReference)cExtendsAssignment_2_1.eContents().get(0);
		private final RuleCall cExtendsEntityIDTerminalRuleCall_2_1_0_1 = (RuleCall)cExtendsEntityCrossReference_2_1_0.eContents().get(1);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cBEGINTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Assignment cAttributesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cAttributesAttributeParserRuleCall_5_0 = (RuleCall)cAttributesAssignment_5.eContents().get(0);
		private final Assignment cRelationshipsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRelationshipsRelationshipParserRuleCall_6_0 = (RuleCall)cRelationshipsAssignment_6.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		////////////////////////////////////////////
		////First Block of statements: entity block
		//Entity:
		//	entityDescLines+=LineComment+
		//	name=OBJID ('->' extends=[Entity])? ':'
		//	BEGIN
		//	attributes+=Attribute+
		//	relationships+=Relationship*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//entityDescLines+=LineComment+ name=OBJID ('->' extends=[Entity])? ':' BEGIN attributes+=Attribute+
		//relationships+=Relationship* END
		public Group getGroup() { return cGroup; }
		
		//entityDescLines+=LineComment+
		public Assignment getEntityDescLinesAssignment_0() { return cEntityDescLinesAssignment_0; }
		
		//LineComment
		public RuleCall getEntityDescLinesLineCommentParserRuleCall_0_0() { return cEntityDescLinesLineCommentParserRuleCall_0_0; }
		
		//name=OBJID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//OBJID
		public RuleCall getNameOBJIDTerminalRuleCall_1_0() { return cNameOBJIDTerminalRuleCall_1_0; }
		
		//('->' extends=[Entity])?
		public Group getGroup_2() { return cGroup_2; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2_0() { return cHyphenMinusGreaterThanSignKeyword_2_0; }
		
		//extends=[Entity]
		public Assignment getExtendsAssignment_2_1() { return cExtendsAssignment_2_1; }
		
		//[Entity]
		public CrossReference getExtendsEntityCrossReference_2_1_0() { return cExtendsEntityCrossReference_2_1_0; }
		
		//ID
		public RuleCall getExtendsEntityIDTerminalRuleCall_2_1_0_1() { return cExtendsEntityIDTerminalRuleCall_2_1_0_1; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_4() { return cBEGINTerminalRuleCall_4; }
		
		//attributes+=Attribute+
		public Assignment getAttributesAssignment_5() { return cAttributesAssignment_5; }
		
		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_5_0() { return cAttributesAttributeParserRuleCall_5_0; }
		
		//relationships+=Relationship*
		public Assignment getRelationshipsAssignment_6() { return cRelationshipsAssignment_6; }
		
		//Relationship
		public RuleCall getRelationshipsRelationshipParserRuleCall_6_0() { return cRelationshipsRelationshipParserRuleCall_6_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_7() { return cENDTerminalRuleCall_7; }
	}
	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.Attribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExtraAttrDescAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExtraAttrDescLineCommentParserRuleCall_0_0 = (RuleCall)cExtraAttrDescAssignment_0.eContents().get(0);
		private final Assignment cDataTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDataTypeDataTypeEnumRuleCall_1_0 = (RuleCall)cDataTypeAssignment_1.eContents().get(0);
		private final Assignment cAttributeSizeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributeSizeAttributeSizeParserRuleCall_2_0 = (RuleCall)cAttributeSizeAssignment_2.eContents().get(0);
		private final Assignment cArraySizeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArraySizeArraySizeParserRuleCall_3_0 = (RuleCall)cArraySizeAssignment_3.eContents().get(0);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameIDTerminalRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cDefaultValueAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cDefaultValueSharkExpressionParserRuleCall_5_1_0 = (RuleCall)cDefaultValueAssignment_5_1.eContents().get(0);
		private final Assignment cPrimaryKeyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cPrimaryKeyPkKeyword_6_0 = (Keyword)cPrimaryKeyAssignment_6.eContents().get(0);
		private final Assignment cMandatoryAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final Keyword cMandatoryExclamationMarkKeyword_7_0 = (Keyword)cMandatoryAssignment_7.eContents().get(0);
		private final Assignment cAttrDescAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cAttrDescTrailCommentParserRuleCall_8_0 = (RuleCall)cAttrDescAssignment_8.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_9 = (RuleCall)cGroup.eContents().get(9);
		
		//////////////Statement 1: Attributes
		////all is initialized and we'll see if that creates perf issue.
		////the unset value constant is either zero or Min and "". it can be overridden in ddt
		//Attribute:
		//	extraAttrDesc+=LineComment*
		//	dataType=DataType attributeSize=AttributeSize?
		//	arraySize=ArraySize?
		//	name=ID ('=' defaultValue=SharkExpression)?
		//	primaryKey?='pk'?
		//	mandatory?='!'?
		//	attrDesc=TrailComment EOL;
		@Override public ParserRule getRule() { return rule; }
		
		//extraAttrDesc+=LineComment* dataType=DataType attributeSize=AttributeSize? arraySize=ArraySize? name=ID ('='
		//defaultValue=SharkExpression)? primaryKey?='pk'? mandatory?='!'? attrDesc=TrailComment EOL
		public Group getGroup() { return cGroup; }
		
		//extraAttrDesc+=LineComment*
		public Assignment getExtraAttrDescAssignment_0() { return cExtraAttrDescAssignment_0; }
		
		//LineComment
		public RuleCall getExtraAttrDescLineCommentParserRuleCall_0_0() { return cExtraAttrDescLineCommentParserRuleCall_0_0; }
		
		//dataType=DataType
		public Assignment getDataTypeAssignment_1() { return cDataTypeAssignment_1; }
		
		//DataType
		public RuleCall getDataTypeDataTypeEnumRuleCall_1_0() { return cDataTypeDataTypeEnumRuleCall_1_0; }
		
		//attributeSize=AttributeSize?
		public Assignment getAttributeSizeAssignment_2() { return cAttributeSizeAssignment_2; }
		
		//AttributeSize
		public RuleCall getAttributeSizeAttributeSizeParserRuleCall_2_0() { return cAttributeSizeAttributeSizeParserRuleCall_2_0; }
		
		//arraySize=ArraySize?
		public Assignment getArraySizeAssignment_3() { return cArraySizeAssignment_3; }
		
		//ArraySize
		public RuleCall getArraySizeArraySizeParserRuleCall_3_0() { return cArraySizeArraySizeParserRuleCall_3_0; }
		
		//name=ID
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_4_0() { return cNameIDTerminalRuleCall_4_0; }
		
		//('=' defaultValue=SharkExpression)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'='
		public Keyword getEqualsSignKeyword_5_0() { return cEqualsSignKeyword_5_0; }
		
		//defaultValue=SharkExpression
		public Assignment getDefaultValueAssignment_5_1() { return cDefaultValueAssignment_5_1; }
		
		//SharkExpression
		public RuleCall getDefaultValueSharkExpressionParserRuleCall_5_1_0() { return cDefaultValueSharkExpressionParserRuleCall_5_1_0; }
		
		//primaryKey?='pk'?
		public Assignment getPrimaryKeyAssignment_6() { return cPrimaryKeyAssignment_6; }
		
		//'pk'
		public Keyword getPrimaryKeyPkKeyword_6_0() { return cPrimaryKeyPkKeyword_6_0; }
		
		//mandatory?='!'?
		public Assignment getMandatoryAssignment_7() { return cMandatoryAssignment_7; }
		
		//'!'
		public Keyword getMandatoryExclamationMarkKeyword_7_0() { return cMandatoryExclamationMarkKeyword_7_0; }
		
		//attrDesc=TrailComment
		public Assignment getAttrDescAssignment_8() { return cAttrDescAssignment_8; }
		
		//TrailComment
		public RuleCall getAttrDescTrailCommentParserRuleCall_8_0() { return cAttrDescTrailCommentParserRuleCall_8_0; }
		
		////mandatory description of the Attribute
		////	(nullable?='!null')? 
		//EOL
		public RuleCall getEOLTerminalRuleCall_9() { return cEOLTerminalRuleCall_9; }
	}
	public class AttributeSizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.AttributeSize");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLengthAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLengthINTTerminalRuleCall_1_0 = (RuleCall)cLengthAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPrecisionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPrecisionINTTerminalRuleCall_2_1_0 = (RuleCall)cPrecisionAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////valid for all types except date time and bool. for int, str and char it can be min max, for dec precision is mandatory
		//AttributeSize:
		//	'(' length=INT (',' precision=INT)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' length=INT (',' precision=INT)? ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//length=INT
		public Assignment getLengthAssignment_1() { return cLengthAssignment_1; }
		
		//INT
		public RuleCall getLengthINTTerminalRuleCall_1_0() { return cLengthINTTerminalRuleCall_1_0; }
		
		//(',' precision=INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//precision=INT
		public Assignment getPrecisionAssignment_2_1() { return cPrecisionAssignment_2_1; }
		
		//INT
		public RuleCall getPrecisionINTTerminalRuleCall_2_1_0() { return cPrecisionINTTerminalRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ArraySizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.ArraySize");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSizeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSizeINTTerminalRuleCall_1_0 = (RuleCall)cSizeAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////not only for constants in this dd context, but also attribute. TODO check cassandra and flatbuuffer impact
		//ArraySize:
		//	'[' size=INT ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' size=INT ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//size=INT
		public Assignment getSizeAssignment_1() { return cSizeAssignment_1; }
		
		//INT
		public RuleCall getSizeINTTerminalRuleCall_1_0() { return cSizeINTTerminalRuleCall_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class RelationshipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.Relationship");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCardi1Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCardi1RangeExpressionParserRuleCall_0_0 = (RuleCall)cCardi1Assignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cCardi2Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCardi2RangeExpressionParserRuleCall_2_0 = (RuleCall)cCardi2Assignment_2.eContents().get(0);
		private final Assignment cLinkToAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cLinkToEntityCrossReference_3_0 = (CrossReference)cLinkToAssignment_3.eContents().get(0);
		private final RuleCall cLinkToEntityOBJIDTerminalRuleCall_3_0_1 = (RuleCall)cLinkToEntityCrossReference_3_0.eContents().get(1);
		private final Assignment cRelDescAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRelDescTrailCommentParserRuleCall_4_0 = (RuleCall)cRelDescAssignment_4.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//////////////Statement 2: Relationships
		//Relationship:
		//	cardi1=RangeExpression name=ID cardi2=RangeExpression linkTo=[Entity|OBJID] relDesc=TrailComment EOL;
		@Override public ParserRule getRule() { return rule; }
		
		//cardi1=RangeExpression name=ID cardi2=RangeExpression linkTo=[Entity|OBJID] relDesc=TrailComment EOL
		public Group getGroup() { return cGroup; }
		
		//cardi1=RangeExpression
		public Assignment getCardi1Assignment_0() { return cCardi1Assignment_0; }
		
		//RangeExpression
		public RuleCall getCardi1RangeExpressionParserRuleCall_0_0() { return cCardi1RangeExpressionParserRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//cardi2=RangeExpression
		public Assignment getCardi2Assignment_2() { return cCardi2Assignment_2; }
		
		//RangeExpression
		public RuleCall getCardi2RangeExpressionParserRuleCall_2_0() { return cCardi2RangeExpressionParserRuleCall_2_0; }
		
		//linkTo=[Entity|OBJID]
		public Assignment getLinkToAssignment_3() { return cLinkToAssignment_3; }
		
		//[Entity|OBJID]
		public CrossReference getLinkToEntityCrossReference_3_0() { return cLinkToEntityCrossReference_3_0; }
		
		//OBJID
		public RuleCall getLinkToEntityOBJIDTerminalRuleCall_3_0_1() { return cLinkToEntityOBJIDTerminalRuleCall_3_0_1; }
		
		//relDesc=TrailComment
		public Assignment getRelDescAssignment_4() { return cRelDescAssignment_4; }
		
		//TrailComment
		public RuleCall getRelDescTrailCommentParserRuleCall_4_0() { return cRelDescTrailCommentParserRuleCall_4_0; }
		
		////mandatory description of the Attribute
		//EOL
		public RuleCall getEOLTerminalRuleCall_5() { return cEOLTerminalRuleCall_5; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cChkDescLinesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cChkDescLinesLineCommentParserRuleCall_0_0 = (RuleCall)cChkDescLinesAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameCHKIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cCheckAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCheckCheckExpressionParserRuleCall_4_0 = (RuleCall)cCheckAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		/////////////////////////////////////////////////
		////Second Block of statements: check constraints
		//Constraint:
		//	chkDescLines+=LineComment+
		//	name=CHKID ':'
		//	BEGIN
		//	check+=CheckExpression+
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//chkDescLines+=LineComment+ name=CHKID ':' BEGIN check+=CheckExpression+ END
		public Group getGroup() { return cGroup; }
		
		//chkDescLines+=LineComment+
		public Assignment getChkDescLinesAssignment_0() { return cChkDescLinesAssignment_0; }
		
		//LineComment
		public RuleCall getChkDescLinesLineCommentParserRuleCall_0_0() { return cChkDescLinesLineCommentParserRuleCall_0_0; }
		
		//name=CHKID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//CHKID
		public RuleCall getNameCHKIDTerminalRuleCall_1_0() { return cNameCHKIDTerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//check+=CheckExpression+
		public Assignment getCheckAssignment_4() { return cCheckAssignment_4; }
		
		//CheckExpression
		public RuleCall getCheckCheckExpressionParserRuleCall_4_0() { return cCheckCheckExpressionParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class CheckExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CheckExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cChkDescAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cChkDescLineCommentParserRuleCall_0_0 = (RuleCall)cChkDescAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprSharkExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//////////////Statement 3: constraints. If same name as entity they are intrinsic and executed systematically
		////at each creation time of the object. The other need to be invoke: check #Customer_Account_Crosschecks.all or .<id>
		//CheckExpression:
		//	chkDesc+=LineComment+
		//	name=ID expr=SharkExpression EOL;
		@Override public ParserRule getRule() { return rule; }
		
		//chkDesc+=LineComment+ name=ID expr=SharkExpression EOL
		public Group getGroup() { return cGroup; }
		
		//chkDesc+=LineComment+
		public Assignment getChkDescAssignment_0() { return cChkDescAssignment_0; }
		
		//LineComment
		public RuleCall getChkDescLineCommentParserRuleCall_0_0() { return cChkDescLineCommentParserRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//expr=SharkExpression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }
		
		//SharkExpression
		public RuleCall getExprSharkExpressionParserRuleCall_2_0() { return cExprSharkExpressionParserRuleCall_2_0; }
		
		//EOL
		public RuleCall getEOLTerminalRuleCall_3() { return cEOLTerminalRuleCall_3; }
	}
	public class SharkExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.SharkExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRangeExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAddExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMultExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAndExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cOrExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cCatExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cListExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cBinaryExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cUnaryExpressionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cTerminalExpressionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cIdentifierExpressionParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		/////////////////////////////////////////////////
		////reusable rules (expression, datatype rules...)
		////below expression are very badly written but easy to understand
		////Start was done with only Binary expressions with brackets and list expressions were added to avoid putting
		////brackets everywhere. This still limits what is allowed to be written but makes it a style that is quite readable
		////avoiding priority and errors of operators
		////Note; syntactic predicate below works only if written in order of priority
		////operation on datetime var: all is done on a time stamp and rounded/cut to keep only the interesting
		////part like only the hours or the date... hence all date compatible
		//SharkExpression:
		//	=> RangeExpression |
		//	=> AddExpression | => MultExpression |
		//	=> AndExpression | => OrExpression |
		//	=> CatExpression | => ListExpression | BinaryExpression | UnaryExpression | TerminalExpression | IdentifierExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//=> RangeExpression | => AddExpression | => MultExpression | => AndExpression | => OrExpression | => CatExpression | =>
		//ListExpression | BinaryExpression | UnaryExpression | TerminalExpression | IdentifierExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> RangeExpression
		public RuleCall getRangeExpressionParserRuleCall_0() { return cRangeExpressionParserRuleCall_0; }
		
		//=> AddExpression
		public RuleCall getAddExpressionParserRuleCall_1() { return cAddExpressionParserRuleCall_1; }
		
		//=> MultExpression
		public RuleCall getMultExpressionParserRuleCall_2() { return cMultExpressionParserRuleCall_2; }
		
		//=> AndExpression
		public RuleCall getAndExpressionParserRuleCall_3() { return cAndExpressionParserRuleCall_3; }
		
		//=> OrExpression
		public RuleCall getOrExpressionParserRuleCall_4() { return cOrExpressionParserRuleCall_4; }
		
		//=> CatExpression
		public RuleCall getCatExpressionParserRuleCall_5() { return cCatExpressionParserRuleCall_5; }
		
		//=> ListExpression
		public RuleCall getListExpressionParserRuleCall_6() { return cListExpressionParserRuleCall_6; }
		
		//BinaryExpression
		public RuleCall getBinaryExpressionParserRuleCall_7() { return cBinaryExpressionParserRuleCall_7; }
		
		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_8() { return cUnaryExpressionParserRuleCall_8; }
		
		//TerminalExpression
		public RuleCall getTerminalExpressionParserRuleCall_9() { return cTerminalExpressionParserRuleCall_9; }
		
		//IdentifierExpression
		public RuleCall getIdentifierExpressionParserRuleCall_10() { return cIdentifierExpressionParserRuleCall_10; }
	}
	public class BinaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.BinaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSharkExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOpBinaryOperatorEnumRuleCall_2_0 = (RuleCall)cOpAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightSharkExpressionParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cNumTypeAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cNumTypeNULLTerminalRuleCall_5_0_0 = (RuleCall)cNumTypeAssignment_5_0.eContents().get(0);
		private final Assignment cStrTypeAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStrTypeNULLTerminalRuleCall_5_1_0 = (RuleCall)cStrTypeAssignment_5_1.eContents().get(0);
		private final Assignment cDateTypeAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cDateTypeNULLTerminalRuleCall_5_2_0 = (RuleCall)cDateTypeAssignment_5_2.eContents().get(0);
		private final Assignment cBoolTypeAssignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cBoolTypeNULLTerminalRuleCall_5_3_0 = (RuleCall)cBoolTypeAssignment_5_3.eContents().get(0);
		
		//BinaryExpression:
		//	'(' left=SharkExpression op=BinaryOperator right=SharkExpression ')' (numType?=NULL strType?=NULL dateType?=NULL
		//	boolType?=NULL)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' left=SharkExpression op=BinaryOperator right=SharkExpression ')' (numType?=NULL strType?=NULL dateType?=NULL
		//boolType?=NULL)?
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_1_0() { return cLeftSharkExpressionParserRuleCall_1_0; }
		
		//op=BinaryOperator
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//BinaryOperator
		public RuleCall getOpBinaryOperatorEnumRuleCall_2_0() { return cOpBinaryOperatorEnumRuleCall_2_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_3_0() { return cRightSharkExpressionParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//(numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup_5() { return cGroup_5; }
		
		//numType?=NULL
		public Assignment getNumTypeAssignment_5_0() { return cNumTypeAssignment_5_0; }
		
		//NULL
		public RuleCall getNumTypeNULLTerminalRuleCall_5_0_0() { return cNumTypeNULLTerminalRuleCall_5_0_0; }
		
		//strType?=NULL
		public Assignment getStrTypeAssignment_5_1() { return cStrTypeAssignment_5_1; }
		
		//NULL
		public RuleCall getStrTypeNULLTerminalRuleCall_5_1_0() { return cStrTypeNULLTerminalRuleCall_5_1_0; }
		
		//dateType?=NULL
		public Assignment getDateTypeAssignment_5_2() { return cDateTypeAssignment_5_2; }
		
		//NULL
		public RuleCall getDateTypeNULLTerminalRuleCall_5_2_0() { return cDateTypeNULLTerminalRuleCall_5_2_0; }
		
		//boolType?=NULL
		public Assignment getBoolTypeAssignment_5_3() { return cBoolTypeAssignment_5_3; }
		
		//NULL
		public RuleCall getBoolTypeNULLTerminalRuleCall_5_3_0() { return cBoolTypeNULLTerminalRuleCall_5_3_0; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpUnaryOperatorEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftSharkExpressionParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cNumTypeAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cNumTypeNULLTerminalRuleCall_4_0_0 = (RuleCall)cNumTypeAssignment_4_0.eContents().get(0);
		private final Assignment cStrTypeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cStrTypeNULLTerminalRuleCall_4_1_0 = (RuleCall)cStrTypeAssignment_4_1.eContents().get(0);
		private final Assignment cDateTypeAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cDateTypeNULLTerminalRuleCall_4_2_0 = (RuleCall)cDateTypeAssignment_4_2.eContents().get(0);
		private final Assignment cBoolTypeAssignment_4_3 = (Assignment)cGroup_4.eContents().get(3);
		private final RuleCall cBoolTypeNULLTerminalRuleCall_4_3_0 = (RuleCall)cBoolTypeAssignment_4_3.eContents().get(0);
		
		//UnaryExpression:
		//	op=UnaryOperator '(' left=SharkExpression ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?;
		@Override public ParserRule getRule() { return rule; }
		
		//op=UnaryOperator '(' left=SharkExpression ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup() { return cGroup; }
		
		//op=UnaryOperator
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//UnaryOperator
		public RuleCall getOpUnaryOperatorEnumRuleCall_0_0() { return cOpUnaryOperatorEnumRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_2_0() { return cLeftSharkExpressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//(numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup_4() { return cGroup_4; }
		
		//numType?=NULL
		public Assignment getNumTypeAssignment_4_0() { return cNumTypeAssignment_4_0; }
		
		//NULL
		public RuleCall getNumTypeNULLTerminalRuleCall_4_0_0() { return cNumTypeNULLTerminalRuleCall_4_0_0; }
		
		//strType?=NULL
		public Assignment getStrTypeAssignment_4_1() { return cStrTypeAssignment_4_1; }
		
		//NULL
		public RuleCall getStrTypeNULLTerminalRuleCall_4_1_0() { return cStrTypeNULLTerminalRuleCall_4_1_0; }
		
		//dateType?=NULL
		public Assignment getDateTypeAssignment_4_2() { return cDateTypeAssignment_4_2; }
		
		//NULL
		public RuleCall getDateTypeNULLTerminalRuleCall_4_2_0() { return cDateTypeNULLTerminalRuleCall_4_2_0; }
		
		//boolType?=NULL
		public Assignment getBoolTypeAssignment_4_3() { return cBoolTypeAssignment_4_3; }
		
		//NULL
		public RuleCall getBoolTypeNULLTerminalRuleCall_4_3_0() { return cBoolTypeNULLTerminalRuleCall_4_3_0; }
	}
	public class AddExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.AddExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSharkExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOpAlternatives_2_0 = (Alternatives)cOpAssignment_2.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_2_0_0 = (Keyword)cOpAlternatives_2_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_2_0_1 = (Keyword)cOpAlternatives_2_0.eContents().get(1);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightSharkExpressionParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Assignment cAddEltsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAddEltsAddExpressionEltParserRuleCall_4_0 = (RuleCall)cAddEltsAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cCheckedAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCheckedNULLTerminalRuleCall_6_0 = (RuleCall)cCheckedAssignment_6.eContents().get(0);
		
		//AddExpression:
		//	'(' left=SharkExpression op=('+' | '-') right=SharkExpression addElts+=AddExpressionElt+ ')'
		//	//to avoid recursive reprocessing
		//	checked?=NULL?;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' left=SharkExpression op=('+' | '-') right=SharkExpression addElts+=AddExpressionElt+ ')' //to avoid recursive reprocessing
		//checked?=NULL?
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_1_0() { return cLeftSharkExpressionParserRuleCall_1_0; }
		
		//op=('+' | '-')
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//('+' | '-')
		public Alternatives getOpAlternatives_2_0() { return cOpAlternatives_2_0; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_2_0_0() { return cOpPlusSignKeyword_2_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_2_0_1() { return cOpHyphenMinusKeyword_2_0_1; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_3_0() { return cRightSharkExpressionParserRuleCall_3_0; }
		
		//addElts+=AddExpressionElt+
		public Assignment getAddEltsAssignment_4() { return cAddEltsAssignment_4; }
		
		//AddExpressionElt
		public RuleCall getAddEltsAddExpressionEltParserRuleCall_4_0() { return cAddEltsAddExpressionEltParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		////to avoid recursive reprocessing
		//checked?=NULL?
		public Assignment getCheckedAssignment_6() { return cCheckedAssignment_6; }
		
		//NULL
		public RuleCall getCheckedNULLTerminalRuleCall_6_0() { return cCheckedNULLTerminalRuleCall_6_0; }
	}
	public class AddExpressionEltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.AddExpressionElt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cOpAlternatives_0_0 = (Alternatives)cOpAssignment_0.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_0_0_0 = (Keyword)cOpAlternatives_0_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_0_0_1 = (Keyword)cOpAlternatives_0_0.eContents().get(1);
		private final Assignment cRightAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRightSharkExpressionParserRuleCall_1_0 = (RuleCall)cRightAssignment_1.eContents().get(0);
		
		//AddExpressionElt:
		//	op=('+' | '-') right=SharkExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op=('+' | '-') right=SharkExpression
		public Group getGroup() { return cGroup; }
		
		//op=('+' | '-')
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//('+' | '-')
		public Alternatives getOpAlternatives_0_0() { return cOpAlternatives_0_0; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_0_0_0() { return cOpPlusSignKeyword_0_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_0_0_1() { return cOpHyphenMinusKeyword_0_0_1; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_1() { return cRightAssignment_1; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_1_0() { return cRightSharkExpressionParserRuleCall_1_0; }
	}
	public class MultExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.MultExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSharkExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cOpAsteriskKeyword_2_0 = (Keyword)cOpAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightSharkExpressionParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Assignment cMultEltsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMultEltsMultExpressionEltParserRuleCall_4_0 = (RuleCall)cMultEltsAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cCheckedAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCheckedNULLTerminalRuleCall_6_0 = (RuleCall)cCheckedAssignment_6.eContents().get(0);
		
		//MultExpression:
		//	'(' left=SharkExpression op='*' right=SharkExpression multElts+=MultExpressionElt+ ')'
		//	//to avoid recursive reprocessing
		//	checked?=NULL?;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' left=SharkExpression op='*' right=SharkExpression multElts+=MultExpressionElt+ ')' //to avoid recursive reprocessing
		//checked?=NULL?
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_1_0() { return cLeftSharkExpressionParserRuleCall_1_0; }
		
		//op='*'
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_2_0() { return cOpAsteriskKeyword_2_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_3_0() { return cRightSharkExpressionParserRuleCall_3_0; }
		
		//multElts+=MultExpressionElt+
		public Assignment getMultEltsAssignment_4() { return cMultEltsAssignment_4; }
		
		//MultExpressionElt
		public RuleCall getMultEltsMultExpressionEltParserRuleCall_4_0() { return cMultEltsMultExpressionEltParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		////to avoid recursive reprocessing
		//checked?=NULL?
		public Assignment getCheckedAssignment_6() { return cCheckedAssignment_6; }
		
		//NULL
		public RuleCall getCheckedNULLTerminalRuleCall_6_0() { return cCheckedNULLTerminalRuleCall_6_0; }
	}
	public class MultExpressionEltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.MultExpressionElt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cRightAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRightSharkExpressionParserRuleCall_1_0 = (RuleCall)cRightAssignment_1.eContents().get(0);
		
		//MultExpressionElt:
		//	op='*' right=SharkExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op='*' right=SharkExpression
		public Group getGroup() { return cGroup; }
		
		//op='*'
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_0_0() { return cOpAsteriskKeyword_0_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_1() { return cRightAssignment_1; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_1_0() { return cRightSharkExpressionParserRuleCall_1_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSharkExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cOpAndKeyword_2_0 = (Keyword)cOpAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightSharkExpressionParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Assignment cAndEltsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAndEltsAndExpressionEltParserRuleCall_4_0 = (RuleCall)cAndEltsAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cCheckedAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCheckedNULLTerminalRuleCall_6_0 = (RuleCall)cCheckedAssignment_6.eContents().get(0);
		
		//AndExpression:
		//	'(' left=SharkExpression op='and' right=SharkExpression andElts+=AndExpressionElt+ ')'
		//	checked?=NULL?;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' left=SharkExpression op='and' right=SharkExpression andElts+=AndExpressionElt+ ')' checked?=NULL?
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_1_0() { return cLeftSharkExpressionParserRuleCall_1_0; }
		
		//op='and'
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//'and'
		public Keyword getOpAndKeyword_2_0() { return cOpAndKeyword_2_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_3_0() { return cRightSharkExpressionParserRuleCall_3_0; }
		
		//andElts+=AndExpressionElt+
		public Assignment getAndEltsAssignment_4() { return cAndEltsAssignment_4; }
		
		//AndExpressionElt
		public RuleCall getAndEltsAndExpressionEltParserRuleCall_4_0() { return cAndEltsAndExpressionEltParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//checked?=NULL?
		public Assignment getCheckedAssignment_6() { return cCheckedAssignment_6; }
		
		//NULL
		public RuleCall getCheckedNULLTerminalRuleCall_6_0() { return cCheckedNULLTerminalRuleCall_6_0; }
	}
	public class AndExpressionEltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.AndExpressionElt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpAndKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cRightAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRightSharkExpressionParserRuleCall_1_0 = (RuleCall)cRightAssignment_1.eContents().get(0);
		
		//AndExpressionElt:
		//	op='and' right=SharkExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op='and' right=SharkExpression
		public Group getGroup() { return cGroup; }
		
		//op='and'
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//'and'
		public Keyword getOpAndKeyword_0_0() { return cOpAndKeyword_0_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_1() { return cRightAssignment_1; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_1_0() { return cRightSharkExpressionParserRuleCall_1_0; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSharkExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cOpOrKeyword_2_0 = (Keyword)cOpAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightSharkExpressionParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Assignment cOrEltsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOrEltsOrExpressionEltParserRuleCall_4_0 = (RuleCall)cOrEltsAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cCheckedAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCheckedNULLTerminalRuleCall_6_0 = (RuleCall)cCheckedAssignment_6.eContents().get(0);
		
		//OrExpression:
		//	'(' left=SharkExpression op='or' right=SharkExpression orElts+=OrExpressionElt+ ')'
		//	checked?=NULL?;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' left=SharkExpression op='or' right=SharkExpression orElts+=OrExpressionElt+ ')' checked?=NULL?
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_1_0() { return cLeftSharkExpressionParserRuleCall_1_0; }
		
		//op='or'
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//'or'
		public Keyword getOpOrKeyword_2_0() { return cOpOrKeyword_2_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_3_0() { return cRightSharkExpressionParserRuleCall_3_0; }
		
		//orElts+=OrExpressionElt+
		public Assignment getOrEltsAssignment_4() { return cOrEltsAssignment_4; }
		
		//OrExpressionElt
		public RuleCall getOrEltsOrExpressionEltParserRuleCall_4_0() { return cOrEltsOrExpressionEltParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//checked?=NULL?
		public Assignment getCheckedAssignment_6() { return cCheckedAssignment_6; }
		
		//NULL
		public RuleCall getCheckedNULLTerminalRuleCall_6_0() { return cCheckedNULLTerminalRuleCall_6_0; }
	}
	public class OrExpressionEltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.OrExpressionElt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpOrKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cRightAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRightSharkExpressionParserRuleCall_1_0 = (RuleCall)cRightAssignment_1.eContents().get(0);
		
		//OrExpressionElt:
		//	op='or' right=SharkExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op='or' right=SharkExpression
		public Group getGroup() { return cGroup; }
		
		//op='or'
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//'or'
		public Keyword getOpOrKeyword_0_0() { return cOpOrKeyword_0_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_1() { return cRightAssignment_1; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_1_0() { return cRightSharkExpressionParserRuleCall_1_0; }
	}
	public class CatExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CatExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSharkExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cOpAmpersandKeyword_2_0 = (Keyword)cOpAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightSharkExpressionParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Assignment cCatEltsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCatEltsCatExpressionEltParserRuleCall_4_0 = (RuleCall)cCatEltsAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cCheckedAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCheckedNULLTerminalRuleCall_6_0 = (RuleCall)cCheckedAssignment_6.eContents().get(0);
		
		//CatExpression:
		//	'(' left=SharkExpression op='&' right=SharkExpression catElts+=CatExpressionElt+ ')'
		//	checked?=NULL?;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' left=SharkExpression op='&' right=SharkExpression catElts+=CatExpressionElt+ ')' checked?=NULL?
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_1_0() { return cLeftSharkExpressionParserRuleCall_1_0; }
		
		//op='&'
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//'&'
		public Keyword getOpAmpersandKeyword_2_0() { return cOpAmpersandKeyword_2_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_3_0() { return cRightSharkExpressionParserRuleCall_3_0; }
		
		//catElts+=CatExpressionElt+
		public Assignment getCatEltsAssignment_4() { return cCatEltsAssignment_4; }
		
		//CatExpressionElt
		public RuleCall getCatEltsCatExpressionEltParserRuleCall_4_0() { return cCatEltsCatExpressionEltParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//checked?=NULL?
		public Assignment getCheckedAssignment_6() { return cCheckedAssignment_6; }
		
		//NULL
		public RuleCall getCheckedNULLTerminalRuleCall_6_0() { return cCheckedNULLTerminalRuleCall_6_0; }
	}
	public class CatExpressionEltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CatExpressionElt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpAmpersandKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cRightAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRightSharkExpressionParserRuleCall_1_0 = (RuleCall)cRightAssignment_1.eContents().get(0);
		
		//CatExpressionElt:
		//	op='&' right=SharkExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op='&' right=SharkExpression
		public Group getGroup() { return cGroup; }
		
		//op='&'
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//'&'
		public Keyword getOpAmpersandKeyword_0_0() { return cOpAmpersandKeyword_0_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_1() { return cRightAssignment_1; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_1_0() { return cRightSharkExpressionParserRuleCall_1_0; }
	}
	public class ListExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.ListExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpLeftParenthesisKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSharkExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cListEltsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListEltsListExpressionEltParserRuleCall_2_0 = (RuleCall)cListEltsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cNumTypeAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cNumTypeNULLTerminalRuleCall_4_0_0 = (RuleCall)cNumTypeAssignment_4_0.eContents().get(0);
		private final Assignment cStrTypeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cStrTypeNULLTerminalRuleCall_4_1_0 = (RuleCall)cStrTypeAssignment_4_1.eContents().get(0);
		private final Assignment cDateTypeAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cDateTypeNULLTerminalRuleCall_4_2_0 = (RuleCall)cDateTypeAssignment_4_2.eContents().get(0);
		private final Assignment cBoolTypeAssignment_4_3 = (Assignment)cGroup_4.eContents().get(3);
		private final RuleCall cBoolTypeNULLTerminalRuleCall_4_3_0 = (RuleCall)cBoolTypeAssignment_4_3.eContents().get(0);
		
		//ListExpression:
		//	op='(' left=SharkExpression ListElts+=ListExpressionElt+ ')' (numType?=NULL strType?=NULL dateType?=NULL
		//	boolType?=NULL)?;
		@Override public ParserRule getRule() { return rule; }
		
		//op='(' left=SharkExpression ListElts+=ListExpressionElt+ ')' (numType?=NULL strType?=NULL dateType?=NULL
		//boolType?=NULL)?
		public Group getGroup() { return cGroup; }
		
		//op='('
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//'('
		public Keyword getOpLeftParenthesisKeyword_0_0() { return cOpLeftParenthesisKeyword_0_0; }
		
		//left=SharkExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//SharkExpression
		public RuleCall getLeftSharkExpressionParserRuleCall_1_0() { return cLeftSharkExpressionParserRuleCall_1_0; }
		
		//ListElts+=ListExpressionElt+
		public Assignment getListEltsAssignment_2() { return cListEltsAssignment_2; }
		
		//ListExpressionElt
		public RuleCall getListEltsListExpressionEltParserRuleCall_2_0() { return cListEltsListExpressionEltParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//(numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup_4() { return cGroup_4; }
		
		//numType?=NULL
		public Assignment getNumTypeAssignment_4_0() { return cNumTypeAssignment_4_0; }
		
		//NULL
		public RuleCall getNumTypeNULLTerminalRuleCall_4_0_0() { return cNumTypeNULLTerminalRuleCall_4_0_0; }
		
		//strType?=NULL
		public Assignment getStrTypeAssignment_4_1() { return cStrTypeAssignment_4_1; }
		
		//NULL
		public RuleCall getStrTypeNULLTerminalRuleCall_4_1_0() { return cStrTypeNULLTerminalRuleCall_4_1_0; }
		
		//dateType?=NULL
		public Assignment getDateTypeAssignment_4_2() { return cDateTypeAssignment_4_2; }
		
		//NULL
		public RuleCall getDateTypeNULLTerminalRuleCall_4_2_0() { return cDateTypeNULLTerminalRuleCall_4_2_0; }
		
		//boolType?=NULL
		public Assignment getBoolTypeAssignment_4_3() { return cBoolTypeAssignment_4_3; }
		
		//NULL
		public RuleCall getBoolTypeNULLTerminalRuleCall_4_3_0() { return cBoolTypeNULLTerminalRuleCall_4_3_0; }
	}
	public class ListExpressionEltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.ListExpressionElt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpCommaKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cRightAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRightSharkExpressionParserRuleCall_1_0 = (RuleCall)cRightAssignment_1.eContents().get(0);
		
		//ListExpressionElt:
		//	op=',' right=SharkExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op=',' right=SharkExpression
		public Group getGroup() { return cGroup; }
		
		//op=','
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//','
		public Keyword getOpCommaKeyword_0_0() { return cOpCommaKeyword_0_0; }
		
		//right=SharkExpression
		public Assignment getRightAssignment_1() { return cRightAssignment_1; }
		
		//SharkExpression
		public RuleCall getRightSharkExpressionParserRuleCall_1_0() { return cRightSharkExpressionParserRuleCall_1_0; }
	}
	public class RangeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.RangeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cListExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cRangeAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cRangeRANGETerminalRuleCall_0_2_0 = (RuleCall)cRangeAssignment_0_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Assignment cNumTypeAssignment_0_4_0 = (Assignment)cGroup_0_4.eContents().get(0);
		private final RuleCall cNumTypeNULLTerminalRuleCall_0_4_0_0 = (RuleCall)cNumTypeAssignment_0_4_0.eContents().get(0);
		private final Assignment cStrTypeAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cStrTypeNULLTerminalRuleCall_0_4_1_0 = (RuleCall)cStrTypeAssignment_0_4_1.eContents().get(0);
		private final Assignment cDateTypeAssignment_0_4_2 = (Assignment)cGroup_0_4.eContents().get(2);
		private final RuleCall cDateTypeNULLTerminalRuleCall_0_4_2_0 = (RuleCall)cDateTypeAssignment_0_4_2.eContents().get(0);
		private final Assignment cBoolTypeAssignment_0_4_3 = (Assignment)cGroup_0_4.eContents().get(3);
		private final RuleCall cBoolTypeNULLTerminalRuleCall_0_4_3_0 = (RuleCall)cBoolTypeAssignment_0_4_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cListExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRangeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRangeRANGEINFTerminalRuleCall_1_2_0 = (RuleCall)cRangeAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_1_4 = (Group)cGroup_1.eContents().get(4);
		private final Assignment cNumTypeAssignment_1_4_0 = (Assignment)cGroup_1_4.eContents().get(0);
		private final RuleCall cNumTypeNULLTerminalRuleCall_1_4_0_0 = (RuleCall)cNumTypeAssignment_1_4_0.eContents().get(0);
		private final Assignment cStrTypeAssignment_1_4_1 = (Assignment)cGroup_1_4.eContents().get(1);
		private final RuleCall cStrTypeNULLTerminalRuleCall_1_4_1_0 = (RuleCall)cStrTypeAssignment_1_4_1.eContents().get(0);
		private final Assignment cDateTypeAssignment_1_4_2 = (Assignment)cGroup_1_4.eContents().get(2);
		private final RuleCall cDateTypeNULLTerminalRuleCall_1_4_2_0 = (RuleCall)cDateTypeAssignment_1_4_2.eContents().get(0);
		private final Assignment cBoolTypeAssignment_1_4_3 = (Assignment)cGroup_1_4.eContents().get(3);
		private final RuleCall cBoolTypeNULLTerminalRuleCall_1_4_3_0 = (RuleCall)cBoolTypeAssignment_1_4_3.eContents().get(0);
		
		//RangeExpression ListExpression:
		//	{ListExpression} '(' range=RANGE ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)? | {ListExpression}
		//	=> '(' range=RANGEINF ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{ListExpression} '(' range=RANGE ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)? | {ListExpression} =>
		//'(' range=RANGEINF ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ListExpression} '(' range=RANGE ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup_0() { return cGroup_0; }
		
		//{ListExpression}
		public Action getListExpressionAction_0_0() { return cListExpressionAction_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//range=RANGE
		public Assignment getRangeAssignment_0_2() { return cRangeAssignment_0_2; }
		
		//RANGE
		public RuleCall getRangeRANGETerminalRuleCall_0_2_0() { return cRangeRANGETerminalRuleCall_0_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_3() { return cRightParenthesisKeyword_0_3; }
		
		//(numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup_0_4() { return cGroup_0_4; }
		
		//numType?=NULL
		public Assignment getNumTypeAssignment_0_4_0() { return cNumTypeAssignment_0_4_0; }
		
		//NULL
		public RuleCall getNumTypeNULLTerminalRuleCall_0_4_0_0() { return cNumTypeNULLTerminalRuleCall_0_4_0_0; }
		
		//strType?=NULL
		public Assignment getStrTypeAssignment_0_4_1() { return cStrTypeAssignment_0_4_1; }
		
		//NULL
		public RuleCall getStrTypeNULLTerminalRuleCall_0_4_1_0() { return cStrTypeNULLTerminalRuleCall_0_4_1_0; }
		
		//dateType?=NULL
		public Assignment getDateTypeAssignment_0_4_2() { return cDateTypeAssignment_0_4_2; }
		
		//NULL
		public RuleCall getDateTypeNULLTerminalRuleCall_0_4_2_0() { return cDateTypeNULLTerminalRuleCall_0_4_2_0; }
		
		//boolType?=NULL
		public Assignment getBoolTypeAssignment_0_4_3() { return cBoolTypeAssignment_0_4_3; }
		
		//NULL
		public RuleCall getBoolTypeNULLTerminalRuleCall_0_4_3_0() { return cBoolTypeNULLTerminalRuleCall_0_4_3_0; }
		
		//{ListExpression} => '(' range=RANGEINF ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{ListExpression}
		public Action getListExpressionAction_1_0() { return cListExpressionAction_1_0; }
		
		//=> '('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//range=RANGEINF
		public Assignment getRangeAssignment_1_2() { return cRangeAssignment_1_2; }
		
		//RANGEINF
		public RuleCall getRangeRANGEINFTerminalRuleCall_1_2_0() { return cRangeRANGEINFTerminalRuleCall_1_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
		
		//(numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?
		public Group getGroup_1_4() { return cGroup_1_4; }
		
		//numType?=NULL
		public Assignment getNumTypeAssignment_1_4_0() { return cNumTypeAssignment_1_4_0; }
		
		//NULL
		public RuleCall getNumTypeNULLTerminalRuleCall_1_4_0_0() { return cNumTypeNULLTerminalRuleCall_1_4_0_0; }
		
		//strType?=NULL
		public Assignment getStrTypeAssignment_1_4_1() { return cStrTypeAssignment_1_4_1; }
		
		//NULL
		public RuleCall getStrTypeNULLTerminalRuleCall_1_4_1_0() { return cStrTypeNULLTerminalRuleCall_1_4_1_0; }
		
		//dateType?=NULL
		public Assignment getDateTypeAssignment_1_4_2() { return cDateTypeAssignment_1_4_2; }
		
		//NULL
		public RuleCall getDateTypeNULLTerminalRuleCall_1_4_2_0() { return cDateTypeNULLTerminalRuleCall_1_4_2_0; }
		
		//boolType?=NULL
		public Assignment getBoolTypeAssignment_1_4_3() { return cBoolTypeAssignment_1_4_3; }
		
		//NULL
		public RuleCall getBoolTypeNULLTerminalRuleCall_1_4_3_0() { return cBoolTypeNULLTerminalRuleCall_1_4_3_0; }
	}
	public class TerminalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.TerminalExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cStrValueAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueSTRTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cIntValueAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cDecValueAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueDECTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cChrValueAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValueCHRTerminalRuleCall_3_1_0 = (RuleCall)cValueAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cCstValueAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cValueConstantCrossReference_4_1_0 = (CrossReference)cValueAssignment_4_1.eContents().get(0);
		private final RuleCall cValueConstantCSTIDTerminalRuleCall_4_1_0_1 = (RuleCall)cValueConstantCrossReference_4_1_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cBoolValueAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cValueAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cValueBooleanEnumRuleCall_5_1_0 = (RuleCall)cValueAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cUnsetValueAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Assignment cValueAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValueUnsetEnumRuleCall_6_1_0 = (RuleCall)cValueAssignment_6_1.eContents().get(0);
		
		//TerminalExpression:
		//	{StrValue} value=STR | {IntValue} value=INT | {DecValue} value=DEC | {ChrValue} value=CHR | {CstValue}
		//	value=[Constant|CSTID] | {BoolValue} value=Boolean | {UnsetValue} value=Unset;
		@Override public ParserRule getRule() { return rule; }
		
		//{StrValue} value=STR | {IntValue} value=INT | {DecValue} value=DEC | {ChrValue} value=CHR | {CstValue}
		//value=[Constant|CSTID] | {BoolValue} value=Boolean | {UnsetValue} value=Unset
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{StrValue} value=STR
		public Group getGroup_0() { return cGroup_0; }
		
		//{StrValue}
		public Action getStrValueAction_0_0() { return cStrValueAction_0_0; }
		
		//value=STR
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//STR
		public RuleCall getValueSTRTerminalRuleCall_0_1_0() { return cValueSTRTerminalRuleCall_0_1_0; }
		
		//{IntValue} value=INT
		public Group getGroup_1() { return cGroup_1; }
		
		//{IntValue}
		public Action getIntValueAction_1_0() { return cIntValueAction_1_0; }
		
		//value=INT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_1_1_0() { return cValueINTTerminalRuleCall_1_1_0; }
		
		//{DecValue} value=DEC
		public Group getGroup_2() { return cGroup_2; }
		
		//{DecValue}
		public Action getDecValueAction_2_0() { return cDecValueAction_2_0; }
		
		//value=DEC
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//DEC
		public RuleCall getValueDECTerminalRuleCall_2_1_0() { return cValueDECTerminalRuleCall_2_1_0; }
		
		//{ChrValue} value=CHR
		public Group getGroup_3() { return cGroup_3; }
		
		//{ChrValue}
		public Action getChrValueAction_3_0() { return cChrValueAction_3_0; }
		
		//value=CHR
		public Assignment getValueAssignment_3_1() { return cValueAssignment_3_1; }
		
		//CHR
		public RuleCall getValueCHRTerminalRuleCall_3_1_0() { return cValueCHRTerminalRuleCall_3_1_0; }
		
		//{CstValue} value=[Constant|CSTID]
		public Group getGroup_4() { return cGroup_4; }
		
		//{CstValue}
		public Action getCstValueAction_4_0() { return cCstValueAction_4_0; }
		
		//value=[Constant|CSTID]
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }
		
		//[Constant|CSTID]
		public CrossReference getValueConstantCrossReference_4_1_0() { return cValueConstantCrossReference_4_1_0; }
		
		//CSTID
		public RuleCall getValueConstantCSTIDTerminalRuleCall_4_1_0_1() { return cValueConstantCSTIDTerminalRuleCall_4_1_0_1; }
		
		//{BoolValue} value=Boolean
		public Group getGroup_5() { return cGroup_5; }
		
		//{BoolValue}
		public Action getBoolValueAction_5_0() { return cBoolValueAction_5_0; }
		
		//value=Boolean
		public Assignment getValueAssignment_5_1() { return cValueAssignment_5_1; }
		
		//Boolean
		public RuleCall getValueBooleanEnumRuleCall_5_1_0() { return cValueBooleanEnumRuleCall_5_1_0; }
		
		//{UnsetValue} value=Unset
		public Group getGroup_6() { return cGroup_6; }
		
		//{UnsetValue}
		public Action getUnsetValueAction_6_0() { return cUnsetValueAction_6_0; }
		
		//value=Unset
		public Assignment getValueAssignment_6_1() { return cValueAssignment_6_1; }
		
		//Unset
		public RuleCall getValueUnsetEnumRuleCall_6_1_0() { return cValueUnsetEnumRuleCall_6_1_0; }
	}
	public class IdentifierExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.IdentifierExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIdentifierExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValueAttributeCrossReference_1_0 = (CrossReference)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueAttributeQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cValueAttributeCrossReference_1_0.eContents().get(1);
		
		//IdentifierExpression TerminalExpression:
		//	{IdentifierExpression} value=[Attribute|QualifiedName];
		@Override public ParserRule getRule() { return rule; }
		
		//{IdentifierExpression} value=[Attribute|QualifiedName]
		public Group getGroup() { return cGroup; }
		
		//{IdentifierExpression}
		public Action getIdentifierExpressionAction_0() { return cIdentifierExpressionAction_0; }
		
		//value=[Attribute|QualifiedName]
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//[Attribute|QualifiedName]
		public CrossReference getValueAttributeCrossReference_1_0() { return cValueAttributeCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getValueAttributeQualifiedNameParserRuleCall_1_0_1() { return cValueAttributeQualifiedNameParserRuleCall_1_0_1; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cOBJIDTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cFullStopKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//QualifiedName:
		//	(OBJID '.')? ID;
		@Override public ParserRule getRule() { return rule; }
		
		//(OBJID '.')? ID
		public Group getGroup() { return cGroup; }
		
		//(OBJID '.')?
		public Group getGroup_0() { return cGroup_0; }
		
		//OBJID
		public RuleCall getOBJIDTerminalRuleCall_0_0() { return cOBJIDTerminalRuleCall_0_0; }
		
		//'.'
		public Keyword getFullStopKeyword_0_1() { return cFullStopKeyword_0_1; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	public class LineCommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.LineComment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCommentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cLineAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLineCMTTerminalRuleCall_1_0 = (RuleCall)cLineAssignment_1.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//LineComment:
		//	{Comment} line=CMT EOL;
		@Override public ParserRule getRule() { return rule; }
		
		//{Comment} line=CMT EOL
		public Group getGroup() { return cGroup; }
		
		//{Comment}
		public Action getCommentAction_0() { return cCommentAction_0; }
		
		//line=CMT
		public Assignment getLineAssignment_1() { return cLineAssignment_1; }
		
		//CMT
		public RuleCall getLineCMTTerminalRuleCall_1_0() { return cLineCMTTerminalRuleCall_1_0; }
		
		//EOL
		public RuleCall getEOLTerminalRuleCall_2() { return cEOLTerminalRuleCall_2; }
	}
	public class TrailCommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.TrailComment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCommentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cLineAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLineCMTTerminalRuleCall_1_0 = (RuleCall)cLineAssignment_1.eContents().get(0);
		
		//TrailComment:
		//	{Comment} line=CMT;
		@Override public ParserRule getRule() { return rule; }
		
		//{Comment} line=CMT
		public Group getGroup() { return cGroup; }
		
		//{Comment}
		public Action getCommentAction_0() { return cCommentAction_0; }
		
		//line=CMT
		public Assignment getLineAssignment_1() { return cLineAssignment_1; }
		
		//CMT
		public RuleCall getLineCMTTerminalRuleCall_1_0() { return cLineCMTTerminalRuleCall_1_0; }
	}
	
	public class BinaryOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.BinaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cOpOrEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cOpOrOrKeyword_0_0 = (Keyword)cOpOrEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOpAndEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOpAndAndKeyword_1_0 = (Keyword)cOpAndEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOpAddEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cOpAddPlusSignKeyword_2_0 = (Keyword)cOpAddEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cOpMinEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cOpMinHyphenMinusKeyword_3_0 = (Keyword)cOpMinEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cOpMultEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cOpMultAsteriskKeyword_4_0 = (Keyword)cOpMultEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cOpDivEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cOpDivSolidusKeyword_5_0 = (Keyword)cOpDivEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cOpModEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cOpModPercentSignKeyword_6_0 = (Keyword)cOpModEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cOpEqEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cOpEqEqualsSignEqualsSignKeyword_7_0 = (Keyword)cOpEqEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cOpGtEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cOpGtGreaterThanSignKeyword_8_0 = (Keyword)cOpGtEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cOpLtEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cOpLtLessThanSignKeyword_9_0 = (Keyword)cOpLtEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cOpLteEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cOpLteLessThanSignEqualsSignKeyword_10_0 = (Keyword)cOpLteEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cOpGteEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cOpGteGreaterThanSignEqualsSignKeyword_11_0 = (Keyword)cOpGteEnumLiteralDeclaration_11.eContents().get(0);
		private final EnumLiteralDeclaration cOpPowEnumLiteralDeclaration_12 = (EnumLiteralDeclaration)cAlternatives.eContents().get(12);
		private final Keyword cOpPowCircumflexAccentKeyword_12_0 = (Keyword)cOpPowEnumLiteralDeclaration_12.eContents().get(0);
		private final EnumLiteralDeclaration cOpLikeEnumLiteralDeclaration_13 = (EnumLiteralDeclaration)cAlternatives.eContents().get(13);
		private final Keyword cOpLikeLikeKeyword_13_0 = (Keyword)cOpLikeEnumLiteralDeclaration_13.eContents().get(0);
		private final EnumLiteralDeclaration cOpDifEnumLiteralDeclaration_14 = (EnumLiteralDeclaration)cAlternatives.eContents().get(14);
		private final Keyword cOpDifExclamationMarkEqualsSignKeyword_14_0 = (Keyword)cOpDifEnumLiteralDeclaration_14.eContents().get(0);
		private final EnumLiteralDeclaration cOpCatEnumLiteralDeclaration_15 = (EnumLiteralDeclaration)cAlternatives.eContents().get(15);
		private final Keyword cOpCatAmpersandKeyword_15_0 = (Keyword)cOpCatEnumLiteralDeclaration_15.eContents().get(0);
		private final EnumLiteralDeclaration cOpInEnumLiteralDeclaration_16 = (EnumLiteralDeclaration)cAlternatives.eContents().get(16);
		private final Keyword cOpInInKeyword_16_0 = (Keyword)cOpInEnumLiteralDeclaration_16.eContents().get(0);
		private final EnumLiteralDeclaration cOpStxtEnumLiteralDeclaration_17 = (EnumLiteralDeclaration)cAlternatives.eContents().get(17);
		private final Keyword cOpStxtStxtKeyword_17_0 = (Keyword)cOpStxtEnumLiteralDeclaration_17.eContents().get(0);
		private final EnumLiteralDeclaration cOpRoundEnumLiteralDeclaration_18 = (EnumLiteralDeclaration)cAlternatives.eContents().get(18);
		private final Keyword cOpRoundRoundKeyword_18_0 = (Keyword)cOpRoundEnumLiteralDeclaration_18.eContents().get(0);
		
		//enum BinaryOperator:
		//	opOr='or' | opAnd='and' | opAdd='+' | opMin='-' | opMult='*' | opDiv='/'
		//	| opMod='%' | opEq='==' | opGt='>' | opLt='<' | opLte='<=' | opGte='>=' | opPow='^'
		//	| opLike='like' | opDif='!=' | opCat='&' | opIn='in' | opStxt='stxt' | opRound='round';
		public EnumRule getRule() { return rule; }
		
		//opOr='or' | opAnd='and' | opAdd='+' | opMin='-' | opMult='*' | opDiv='/' | opMod='%' | opEq='==' | opGt='>' | opLt='<' |
		//opLte='<=' | opGte='>=' | opPow='^' | opLike='like' | opDif='!=' | opCat='&' | opIn='in' | opStxt='stxt' |
		//opRound='round'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//opOr='or'
		public EnumLiteralDeclaration getOpOrEnumLiteralDeclaration_0() { return cOpOrEnumLiteralDeclaration_0; }
		
		//'or'
		public Keyword getOpOrOrKeyword_0_0() { return cOpOrOrKeyword_0_0; }
		
		//opAnd='and'
		public EnumLiteralDeclaration getOpAndEnumLiteralDeclaration_1() { return cOpAndEnumLiteralDeclaration_1; }
		
		//'and'
		public Keyword getOpAndAndKeyword_1_0() { return cOpAndAndKeyword_1_0; }
		
		//opAdd='+'
		public EnumLiteralDeclaration getOpAddEnumLiteralDeclaration_2() { return cOpAddEnumLiteralDeclaration_2; }
		
		//'+'
		public Keyword getOpAddPlusSignKeyword_2_0() { return cOpAddPlusSignKeyword_2_0; }
		
		//opMin='-'
		public EnumLiteralDeclaration getOpMinEnumLiteralDeclaration_3() { return cOpMinEnumLiteralDeclaration_3; }
		
		//'-'
		public Keyword getOpMinHyphenMinusKeyword_3_0() { return cOpMinHyphenMinusKeyword_3_0; }
		
		//opMult='*'
		public EnumLiteralDeclaration getOpMultEnumLiteralDeclaration_4() { return cOpMultEnumLiteralDeclaration_4; }
		
		//'*'
		public Keyword getOpMultAsteriskKeyword_4_0() { return cOpMultAsteriskKeyword_4_0; }
		
		//opDiv='/'
		public EnumLiteralDeclaration getOpDivEnumLiteralDeclaration_5() { return cOpDivEnumLiteralDeclaration_5; }
		
		//'/'
		public Keyword getOpDivSolidusKeyword_5_0() { return cOpDivSolidusKeyword_5_0; }
		
		//opMod='%'
		public EnumLiteralDeclaration getOpModEnumLiteralDeclaration_6() { return cOpModEnumLiteralDeclaration_6; }
		
		//'%'
		public Keyword getOpModPercentSignKeyword_6_0() { return cOpModPercentSignKeyword_6_0; }
		
		//opEq='=='
		public EnumLiteralDeclaration getOpEqEnumLiteralDeclaration_7() { return cOpEqEnumLiteralDeclaration_7; }
		
		//'=='
		public Keyword getOpEqEqualsSignEqualsSignKeyword_7_0() { return cOpEqEqualsSignEqualsSignKeyword_7_0; }
		
		//opGt='>'
		public EnumLiteralDeclaration getOpGtEnumLiteralDeclaration_8() { return cOpGtEnumLiteralDeclaration_8; }
		
		//'>'
		public Keyword getOpGtGreaterThanSignKeyword_8_0() { return cOpGtGreaterThanSignKeyword_8_0; }
		
		//opLt='<'
		public EnumLiteralDeclaration getOpLtEnumLiteralDeclaration_9() { return cOpLtEnumLiteralDeclaration_9; }
		
		//'<'
		public Keyword getOpLtLessThanSignKeyword_9_0() { return cOpLtLessThanSignKeyword_9_0; }
		
		//opLte='<='
		public EnumLiteralDeclaration getOpLteEnumLiteralDeclaration_10() { return cOpLteEnumLiteralDeclaration_10; }
		
		//'<='
		public Keyword getOpLteLessThanSignEqualsSignKeyword_10_0() { return cOpLteLessThanSignEqualsSignKeyword_10_0; }
		
		//opGte='>='
		public EnumLiteralDeclaration getOpGteEnumLiteralDeclaration_11() { return cOpGteEnumLiteralDeclaration_11; }
		
		//'>='
		public Keyword getOpGteGreaterThanSignEqualsSignKeyword_11_0() { return cOpGteGreaterThanSignEqualsSignKeyword_11_0; }
		
		//opPow='^'
		public EnumLiteralDeclaration getOpPowEnumLiteralDeclaration_12() { return cOpPowEnumLiteralDeclaration_12; }
		
		//'^'
		public Keyword getOpPowCircumflexAccentKeyword_12_0() { return cOpPowCircumflexAccentKeyword_12_0; }
		
		//opLike='like'
		public EnumLiteralDeclaration getOpLikeEnumLiteralDeclaration_13() { return cOpLikeEnumLiteralDeclaration_13; }
		
		//'like'
		public Keyword getOpLikeLikeKeyword_13_0() { return cOpLikeLikeKeyword_13_0; }
		
		//opDif='!='
		public EnumLiteralDeclaration getOpDifEnumLiteralDeclaration_14() { return cOpDifEnumLiteralDeclaration_14; }
		
		//'!='
		public Keyword getOpDifExclamationMarkEqualsSignKeyword_14_0() { return cOpDifExclamationMarkEqualsSignKeyword_14_0; }
		
		//opCat='&'
		public EnumLiteralDeclaration getOpCatEnumLiteralDeclaration_15() { return cOpCatEnumLiteralDeclaration_15; }
		
		//'&'
		public Keyword getOpCatAmpersandKeyword_15_0() { return cOpCatAmpersandKeyword_15_0; }
		
		//opIn='in'
		public EnumLiteralDeclaration getOpInEnumLiteralDeclaration_16() { return cOpInEnumLiteralDeclaration_16; }
		
		//'in'
		public Keyword getOpInInKeyword_16_0() { return cOpInInKeyword_16_0; }
		
		//opStxt='stxt'
		public EnumLiteralDeclaration getOpStxtEnumLiteralDeclaration_17() { return cOpStxtEnumLiteralDeclaration_17; }
		
		//'stxt'
		public Keyword getOpStxtStxtKeyword_17_0() { return cOpStxtStxtKeyword_17_0; }
		
		//opRound='round'
		public EnumLiteralDeclaration getOpRoundEnumLiteralDeclaration_18() { return cOpRoundEnumLiteralDeclaration_18; }
		
		//'round'
		public Keyword getOpRoundRoundKeyword_18_0() { return cOpRoundRoundKeyword_18_0; }
	}
	public class UnaryOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cOpNotEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cOpNotNotKeyword_0_0 = (Keyword)cOpNotEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOpNegEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOpNegHyphenMinusKeyword_1_0 = (Keyword)cOpNegEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cStrCastEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cStrCastStrKeyword_2_0 = (Keyword)cStrCastEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cIntCastEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cIntCastIntKeyword_3_0 = (Keyword)cIntCastEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cDecCastEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cDecCastDecKeyword_4_0 = (Keyword)cDecCastEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cDateCastEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cDateCastDateKeyword_5_0 = (Keyword)cDateCastEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cTimeCastEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cTimeCastTimeKeyword_6_0 = (Keyword)cTimeCastEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cOpLenEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cOpLenLenKeyword_7_0 = (Keyword)cOpLenEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cStampCastEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cStampCastStampKeyword_8_0 = (Keyword)cStampCastEnumLiteralDeclaration_8.eContents().get(0);
		
		//enum UnaryOperator:
		//	opNot='not' | opNeg='-' | strCast='str' | intCast='int' | decCast='dec' | dateCast='date' |
		//	timeCast='time' | opLen='len' | stampCast='stamp';
		public EnumRule getRule() { return rule; }
		
		//opNot='not' | opNeg='-' | strCast='str' | intCast='int' | decCast='dec' | dateCast='date' | timeCast='time' |
		//opLen='len' | stampCast='stamp'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//opNot='not'
		public EnumLiteralDeclaration getOpNotEnumLiteralDeclaration_0() { return cOpNotEnumLiteralDeclaration_0; }
		
		//'not'
		public Keyword getOpNotNotKeyword_0_0() { return cOpNotNotKeyword_0_0; }
		
		//opNeg='-'
		public EnumLiteralDeclaration getOpNegEnumLiteralDeclaration_1() { return cOpNegEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getOpNegHyphenMinusKeyword_1_0() { return cOpNegHyphenMinusKeyword_1_0; }
		
		//strCast='str'
		public EnumLiteralDeclaration getStrCastEnumLiteralDeclaration_2() { return cStrCastEnumLiteralDeclaration_2; }
		
		//'str'
		public Keyword getStrCastStrKeyword_2_0() { return cStrCastStrKeyword_2_0; }
		
		//intCast='int'
		public EnumLiteralDeclaration getIntCastEnumLiteralDeclaration_3() { return cIntCastEnumLiteralDeclaration_3; }
		
		//'int'
		public Keyword getIntCastIntKeyword_3_0() { return cIntCastIntKeyword_3_0; }
		
		//decCast='dec'
		public EnumLiteralDeclaration getDecCastEnumLiteralDeclaration_4() { return cDecCastEnumLiteralDeclaration_4; }
		
		//'dec'
		public Keyword getDecCastDecKeyword_4_0() { return cDecCastDecKeyword_4_0; }
		
		//dateCast='date'
		public EnumLiteralDeclaration getDateCastEnumLiteralDeclaration_5() { return cDateCastEnumLiteralDeclaration_5; }
		
		//'date'
		public Keyword getDateCastDateKeyword_5_0() { return cDateCastDateKeyword_5_0; }
		
		//timeCast='time'
		public EnumLiteralDeclaration getTimeCastEnumLiteralDeclaration_6() { return cTimeCastEnumLiteralDeclaration_6; }
		
		//'time'
		public Keyword getTimeCastTimeKeyword_6_0() { return cTimeCastTimeKeyword_6_0; }
		
		//opLen='len'
		public EnumLiteralDeclaration getOpLenEnumLiteralDeclaration_7() { return cOpLenEnumLiteralDeclaration_7; }
		
		//'len'
		public Keyword getOpLenLenKeyword_7_0() { return cOpLenLenKeyword_7_0; }
		
		//stampCast='stamp'
		public EnumLiteralDeclaration getStampCastEnumLiteralDeclaration_8() { return cStampCastEnumLiteralDeclaration_8; }
		
		//'stamp'
		public Keyword getStampCastStampKeyword_8_0() { return cStampCastStampKeyword_8_0; }
	}
	public class UnsetElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.Unset");
		private final EnumLiteralDeclaration cUnsetEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cUnsetUnsetKeyword_0 = (Keyword)cUnsetEnumLiteralDeclaration.eContents().get(0);
		
		//enum Unset:
		//	unset;
		public EnumRule getRule() { return rule; }
		
		//unset
		public EnumLiteralDeclaration getUnsetEnumLiteralDeclaration() { return cUnsetEnumLiteralDeclaration; }
		
		//'unset'
		public Keyword getUnsetUnsetKeyword_0() { return cUnsetUnsetKeyword_0; }
	}
	public class BooleanElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.Boolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTrueCstEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTrueCstTrueKeyword_0_0 = (Keyword)cTrueCstEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFalseCstEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFalseCstFalseKeyword_1_0 = (Keyword)cFalseCstEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Boolean:
		//	trueCst='true' |
		//	falseCst='false';
		public EnumRule getRule() { return rule; }
		
		//trueCst='true' | falseCst='false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//trueCst='true'
		public EnumLiteralDeclaration getTrueCstEnumLiteralDeclaration_0() { return cTrueCstEnumLiteralDeclaration_0; }
		
		//'true'
		public Keyword getTrueCstTrueKeyword_0_0() { return cTrueCstTrueKeyword_0_0; }
		
		//falseCst='false'
		public EnumLiteralDeclaration getFalseCstEnumLiteralDeclaration_1() { return cFalseCstEnumLiteralDeclaration_1; }
		
		//'false'
		public Keyword getFalseCstFalseKeyword_1_0() { return cFalseCstFalseKeyword_1_0; }
	}
	public class DataTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.DataType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cStrEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cStrStrKeyword_0_0 = (Keyword)cStrEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDecEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDecDecKeyword_1_0 = (Keyword)cDecEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDateEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDateDateKeyword_2_0 = (Keyword)cDateEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cTimeEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cTimeTimeKeyword_3_0 = (Keyword)cTimeEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cChrEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cChrChrKeyword_4_0 = (Keyword)cChrEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cIntEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cIntIntKeyword_5_0 = (Keyword)cIntEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cStampEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cStampStampKeyword_6_0 = (Keyword)cStampEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cBitsEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cBitsBitsKeyword_7_0 = (Keyword)cBitsEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cBoolEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cBoolBoolKeyword_8_0 = (Keyword)cBoolEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cUnsetEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cUnsetHalfwidthHangulFillerHalfwidthHangulFillerHalfwidthHangulFillerKeyword_9_0 = (Keyword)cUnsetEnumLiteralDeclaration_9.eContents().get(0);
		
		//enum DataType:
		//	str | dec | date | time | chr | int | stamp | bits | bool |
		//	unset='\\uFFA0\\uFFA0\\uFFA0';
		public EnumRule getRule() { return rule; }
		
		//str | dec | date | time | chr | int | stamp | bits | bool | unset='\\uFFA0\\uFFA0\\uFFA0'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//str
		public EnumLiteralDeclaration getStrEnumLiteralDeclaration_0() { return cStrEnumLiteralDeclaration_0; }
		
		//'str'
		public Keyword getStrStrKeyword_0_0() { return cStrStrKeyword_0_0; }
		
		//dec
		public EnumLiteralDeclaration getDecEnumLiteralDeclaration_1() { return cDecEnumLiteralDeclaration_1; }
		
		//'dec'
		public Keyword getDecDecKeyword_1_0() { return cDecDecKeyword_1_0; }
		
		//date
		public EnumLiteralDeclaration getDateEnumLiteralDeclaration_2() { return cDateEnumLiteralDeclaration_2; }
		
		//'date'
		public Keyword getDateDateKeyword_2_0() { return cDateDateKeyword_2_0; }
		
		//time
		public EnumLiteralDeclaration getTimeEnumLiteralDeclaration_3() { return cTimeEnumLiteralDeclaration_3; }
		
		//'time'
		public Keyword getTimeTimeKeyword_3_0() { return cTimeTimeKeyword_3_0; }
		
		//chr
		public EnumLiteralDeclaration getChrEnumLiteralDeclaration_4() { return cChrEnumLiteralDeclaration_4; }
		
		//'chr'
		public Keyword getChrChrKeyword_4_0() { return cChrChrKeyword_4_0; }
		
		//int
		public EnumLiteralDeclaration getIntEnumLiteralDeclaration_5() { return cIntEnumLiteralDeclaration_5; }
		
		//'int'
		public Keyword getIntIntKeyword_5_0() { return cIntIntKeyword_5_0; }
		
		//stamp
		public EnumLiteralDeclaration getStampEnumLiteralDeclaration_6() { return cStampEnumLiteralDeclaration_6; }
		
		//'stamp'
		public Keyword getStampStampKeyword_6_0() { return cStampStampKeyword_6_0; }
		
		//bits
		public EnumLiteralDeclaration getBitsEnumLiteralDeclaration_7() { return cBitsEnumLiteralDeclaration_7; }
		
		//'bits'
		public Keyword getBitsBitsKeyword_7_0() { return cBitsBitsKeyword_7_0; }
		
		//bool
		public EnumLiteralDeclaration getBoolEnumLiteralDeclaration_8() { return cBoolEnumLiteralDeclaration_8; }
		
		//'bool'
		public Keyword getBoolBoolKeyword_8_0() { return cBoolBoolKeyword_8_0; }
		
		//unset='\\uFFA0\\uFFA0\\uFFA0'
		public EnumLiteralDeclaration getUnsetEnumLiteralDeclaration_9() { return cUnsetEnumLiteralDeclaration_9; }
		
		//'\\uFFA0\\uFFA0\\uFFA0'
		public Keyword getUnsetHalfwidthHangulFillerHalfwidthHangulFillerHalfwidthHangulFillerKeyword_9_0() { return cUnsetHalfwidthHangulFillerHalfwidthHangulFillerHalfwidthHangulFillerKeyword_9_0; }
	}
	
	private final DataModelFragmentElements pDataModelFragment;
	private final ConstantElements pConstant;
	private final EntityElements pEntity;
	private final AttributeElements pAttribute;
	private final AttributeSizeElements pAttributeSize;
	private final ArraySizeElements pArraySize;
	private final RelationshipElements pRelationship;
	private final ConstraintElements pConstraint;
	private final CheckExpressionElements pCheckExpression;
	private final SharkExpressionElements pSharkExpression;
	private final BinaryExpressionElements pBinaryExpression;
	private final UnaryExpressionElements pUnaryExpression;
	private final AddExpressionElements pAddExpression;
	private final AddExpressionEltElements pAddExpressionElt;
	private final MultExpressionElements pMultExpression;
	private final MultExpressionEltElements pMultExpressionElt;
	private final AndExpressionElements pAndExpression;
	private final AndExpressionEltElements pAndExpressionElt;
	private final OrExpressionElements pOrExpression;
	private final OrExpressionEltElements pOrExpressionElt;
	private final CatExpressionElements pCatExpression;
	private final CatExpressionEltElements pCatExpressionElt;
	private final ListExpressionElements pListExpression;
	private final ListExpressionEltElements pListExpressionElt;
	private final RangeExpressionElements pRangeExpression;
	private final BinaryOperatorElements eBinaryOperator;
	private final UnaryOperatorElements eUnaryOperator;
	private final TerminalExpressionElements pTerminalExpression;
	private final IdentifierExpressionElements pIdentifierExpression;
	private final QualifiedNameElements pQualifiedName;
	private final LineCommentElements pLineComment;
	private final TrailCommentElements pTrailComment;
	private final UnsetElements eUnset;
	private final BooleanElements eBoolean;
	private final DataTypeElements eDataType;
	private final TerminalRule tBEGIN;
	private final TerminalRule tEND;
	private final TerminalRule tEOL;
	private final TerminalRule tNULL;
	private final TerminalRule tHEX;
	private final TerminalRule tNUM;
	private final TerminalRule tUNI;
	private final TerminalRule tESC;
	private final TerminalRule tASCII;
	private final TerminalRule tNL;
	private final TerminalRule tCHR;
	private final TerminalRule tSTR;
	private final TerminalRule tRANGEINF;
	private final TerminalRule tRANGE;
	private final TerminalRule tCHKID;
	private final TerminalRule tCSTID;
	private final TerminalRule tOBJID;
	private final TerminalRule tID;
	private final TerminalRule tDEC;
	private final TerminalRule tINT;
	private final TerminalRule tCONT;
	private final TerminalRule tIDENT;
	private final TerminalRule tCMT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public DdGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pDataModelFragment = new DataModelFragmentElements();
		this.pConstant = new ConstantElements();
		this.pEntity = new EntityElements();
		this.pAttribute = new AttributeElements();
		this.pAttributeSize = new AttributeSizeElements();
		this.pArraySize = new ArraySizeElements();
		this.pRelationship = new RelationshipElements();
		this.pConstraint = new ConstraintElements();
		this.pCheckExpression = new CheckExpressionElements();
		this.pSharkExpression = new SharkExpressionElements();
		this.pBinaryExpression = new BinaryExpressionElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pAddExpression = new AddExpressionElements();
		this.pAddExpressionElt = new AddExpressionEltElements();
		this.pMultExpression = new MultExpressionElements();
		this.pMultExpressionElt = new MultExpressionEltElements();
		this.pAndExpression = new AndExpressionElements();
		this.pAndExpressionElt = new AndExpressionEltElements();
		this.pOrExpression = new OrExpressionElements();
		this.pOrExpressionElt = new OrExpressionEltElements();
		this.pCatExpression = new CatExpressionElements();
		this.pCatExpressionElt = new CatExpressionEltElements();
		this.pListExpression = new ListExpressionElements();
		this.pListExpressionElt = new ListExpressionEltElements();
		this.pRangeExpression = new RangeExpressionElements();
		this.eBinaryOperator = new BinaryOperatorElements();
		this.eUnaryOperator = new UnaryOperatorElements();
		this.pTerminalExpression = new TerminalExpressionElements();
		this.pIdentifierExpression = new IdentifierExpressionElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pLineComment = new LineCommentElements();
		this.pTrailComment = new TrailCommentElements();
		this.eUnset = new UnsetElements();
		this.eBoolean = new BooleanElements();
		this.eDataType = new DataTypeElements();
		this.tBEGIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.BEGIN");
		this.tEND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.END");
		this.tEOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.EOL");
		this.tNULL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.NULL");
		this.tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.HEX");
		this.tNUM = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.NUM");
		this.tUNI = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.UNI");
		this.tESC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.ESC");
		this.tASCII = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.ASCII");
		this.tNL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.NL");
		this.tCHR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CHR");
		this.tSTR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.STR");
		this.tRANGEINF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.RANGEINF");
		this.tRANGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.RANGE");
		this.tCHKID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CHKID");
		this.tCSTID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CSTID");
		this.tOBJID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.OBJID");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.ID");
		this.tDEC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.DEC");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.INT");
		this.tCONT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CONT");
		this.tIDENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.IDENT");
		this.tCMT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.CMT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.shark.lang.Dd.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.shark.lang.Dd".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	////no empty entity and so mandatory BEGIN/END structure
	////BEGIN / END added when there is an indent level change
	////EOL tokens are added after an indent constant or no indent and a new line
	////IDENT triggered after a Comment so generates EOL 
	////with such grammar, comment are controlled for metrics and positioning --> not free anywhere --> there and concise
	////TODO improve display of outline with name attribute
	////TODO document design and classes and some design decisions in the grammar as comments here
	////TODO test expressions interactively and build non passing JUNIT tests using excel random
	////TODO check cast date format
	////TODO check empty string const on like
	////TODO validation of cross entity checks if not 1-1
	////TODO customize error messages for parser and lexer: eg constant en maj
	////TODO do a first output
	////TODO update formatter
	////TODO semantic highlighting example, true / false in yellow and decl in bold
	////TODO add formats on top of checks to be used by like operator: 5A003a-"H" with positions. formats will be usable to split
	////TODO test date operations + 1*DAY... basing on the generator error management
	////TODO add min, max, avg
	////TODO ad validation of size vs. real constant or init value size, like wise for list size, decimal precision...
	////TODO move to github
	////TODO add content assist
	////TODO split into reusable grammar and create sd and sk languages
	////TODO implement math a bit more: implement the expression precision check and rounding routines
	////TODO in this context consider removing int and stick to general dec(n,0)?
	////TODO as for constant they need to be calculatable expressions at compile time so use groovy or other in 
	////Validation to evaluate it, but keep the expression in java as the java compiler will simplify then.
	////TODO check and neutralize useless comment associator
	////TODO check that all text is assigned
	////TODO change the outline view with several levels: summary pretty and full. the full lone would look like the 
	////ecore sample editor. editor read again the XtextRessource so normal that my boolean are not there. they would have to 
	////be persisted in hidden text... But core code generation maybe the in memory AST is the same as in validation
	////to test.
	//DataModelFragment:
	//	constants+=Constant*
	//	entities+=Entity*
	//	constraints+=Constraint*;
	public DataModelFragmentElements getDataModelFragmentAccess() {
		return pDataModelFragment;
	}
	
	public ParserRule getDataModelFragmentRule() {
		return getDataModelFragmentAccess().getRule();
	}
	
	///////////////////////////
	////Statement 0: constants
	//Constant:
	//	extraAttrDesc+=LineComment*
	//	dataType=DataType
	//	attributeSize=AttributeSize?
	//	arraySize=ArraySize?
	//	name=CSTID ('=' defaultValue=SharkExpression) attrDesc=TrailComment EOL;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	////////////////////////////////////////////
	////First Block of statements: entity block
	//Entity:
	//	entityDescLines+=LineComment+
	//	name=OBJID ('->' extends=[Entity])? ':'
	//	BEGIN
	//	attributes+=Attribute+
	//	relationships+=Relationship*
	//	END;
	public EntityElements getEntityAccess() {
		return pEntity;
	}
	
	public ParserRule getEntityRule() {
		return getEntityAccess().getRule();
	}
	
	//////////////Statement 1: Attributes
	////all is initialized and we'll see if that creates perf issue.
	////the unset value constant is either zero or Min and "". it can be overridden in ddt
	//Attribute:
	//	extraAttrDesc+=LineComment*
	//	dataType=DataType attributeSize=AttributeSize?
	//	arraySize=ArraySize?
	//	name=ID ('=' defaultValue=SharkExpression)?
	//	primaryKey?='pk'?
	//	mandatory?='!'?
	//	attrDesc=TrailComment EOL;
	public AttributeElements getAttributeAccess() {
		return pAttribute;
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}
	
	////valid for all types except date time and bool. for int, str and char it can be min max, for dec precision is mandatory
	//AttributeSize:
	//	'(' length=INT (',' precision=INT)? ')';
	public AttributeSizeElements getAttributeSizeAccess() {
		return pAttributeSize;
	}
	
	public ParserRule getAttributeSizeRule() {
		return getAttributeSizeAccess().getRule();
	}
	
	////not only for constants in this dd context, but also attribute. TODO check cassandra and flatbuuffer impact
	//ArraySize:
	//	'[' size=INT ']';
	public ArraySizeElements getArraySizeAccess() {
		return pArraySize;
	}
	
	public ParserRule getArraySizeRule() {
		return getArraySizeAccess().getRule();
	}
	
	//////////////Statement 2: Relationships
	//Relationship:
	//	cardi1=RangeExpression name=ID cardi2=RangeExpression linkTo=[Entity|OBJID] relDesc=TrailComment EOL;
	public RelationshipElements getRelationshipAccess() {
		return pRelationship;
	}
	
	public ParserRule getRelationshipRule() {
		return getRelationshipAccess().getRule();
	}
	
	/////////////////////////////////////////////////
	////Second Block of statements: check constraints
	//Constraint:
	//	chkDescLines+=LineComment+
	//	name=CHKID ':'
	//	BEGIN
	//	check+=CheckExpression+
	//	END;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//////////////Statement 3: constraints. If same name as entity they are intrinsic and executed systematically
	////at each creation time of the object. The other need to be invoke: check #Customer_Account_Crosschecks.all or .<id>
	//CheckExpression:
	//	chkDesc+=LineComment+
	//	name=ID expr=SharkExpression EOL;
	public CheckExpressionElements getCheckExpressionAccess() {
		return pCheckExpression;
	}
	
	public ParserRule getCheckExpressionRule() {
		return getCheckExpressionAccess().getRule();
	}
	
	/////////////////////////////////////////////////
	////reusable rules (expression, datatype rules...)
	////below expression are very badly written but easy to understand
	////Start was done with only Binary expressions with brackets and list expressions were added to avoid putting
	////brackets everywhere. This still limits what is allowed to be written but makes it a style that is quite readable
	////avoiding priority and errors of operators
	////Note; syntactic predicate below works only if written in order of priority
	////operation on datetime var: all is done on a time stamp and rounded/cut to keep only the interesting
	////part like only the hours or the date... hence all date compatible
	//SharkExpression:
	//	=> RangeExpression |
	//	=> AddExpression | => MultExpression |
	//	=> AndExpression | => OrExpression |
	//	=> CatExpression | => ListExpression | BinaryExpression | UnaryExpression | TerminalExpression | IdentifierExpression;
	public SharkExpressionElements getSharkExpressionAccess() {
		return pSharkExpression;
	}
	
	public ParserRule getSharkExpressionRule() {
		return getSharkExpressionAccess().getRule();
	}
	
	//BinaryExpression:
	//	'(' left=SharkExpression op=BinaryOperator right=SharkExpression ')' (numType?=NULL strType?=NULL dateType?=NULL
	//	boolType?=NULL)?;
	public BinaryExpressionElements getBinaryExpressionAccess() {
		return pBinaryExpression;
	}
	
	public ParserRule getBinaryExpressionRule() {
		return getBinaryExpressionAccess().getRule();
	}
	
	//UnaryExpression:
	//	op=UnaryOperator '(' left=SharkExpression ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//AddExpression:
	//	'(' left=SharkExpression op=('+' | '-') right=SharkExpression addElts+=AddExpressionElt+ ')'
	//	//to avoid recursive reprocessing
	//	checked?=NULL?;
	public AddExpressionElements getAddExpressionAccess() {
		return pAddExpression;
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}
	
	//AddExpressionElt:
	//	op=('+' | '-') right=SharkExpression;
	public AddExpressionEltElements getAddExpressionEltAccess() {
		return pAddExpressionElt;
	}
	
	public ParserRule getAddExpressionEltRule() {
		return getAddExpressionEltAccess().getRule();
	}
	
	//MultExpression:
	//	'(' left=SharkExpression op='*' right=SharkExpression multElts+=MultExpressionElt+ ')'
	//	//to avoid recursive reprocessing
	//	checked?=NULL?;
	public MultExpressionElements getMultExpressionAccess() {
		return pMultExpression;
	}
	
	public ParserRule getMultExpressionRule() {
		return getMultExpressionAccess().getRule();
	}
	
	//MultExpressionElt:
	//	op='*' right=SharkExpression;
	public MultExpressionEltElements getMultExpressionEltAccess() {
		return pMultExpressionElt;
	}
	
	public ParserRule getMultExpressionEltRule() {
		return getMultExpressionEltAccess().getRule();
	}
	
	//AndExpression:
	//	'(' left=SharkExpression op='and' right=SharkExpression andElts+=AndExpressionElt+ ')'
	//	checked?=NULL?;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//AndExpressionElt:
	//	op='and' right=SharkExpression;
	public AndExpressionEltElements getAndExpressionEltAccess() {
		return pAndExpressionElt;
	}
	
	public ParserRule getAndExpressionEltRule() {
		return getAndExpressionEltAccess().getRule();
	}
	
	//OrExpression:
	//	'(' left=SharkExpression op='or' right=SharkExpression orElts+=OrExpressionElt+ ')'
	//	checked?=NULL?;
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//OrExpressionElt:
	//	op='or' right=SharkExpression;
	public OrExpressionEltElements getOrExpressionEltAccess() {
		return pOrExpressionElt;
	}
	
	public ParserRule getOrExpressionEltRule() {
		return getOrExpressionEltAccess().getRule();
	}
	
	//CatExpression:
	//	'(' left=SharkExpression op='&' right=SharkExpression catElts+=CatExpressionElt+ ')'
	//	checked?=NULL?;
	public CatExpressionElements getCatExpressionAccess() {
		return pCatExpression;
	}
	
	public ParserRule getCatExpressionRule() {
		return getCatExpressionAccess().getRule();
	}
	
	//CatExpressionElt:
	//	op='&' right=SharkExpression;
	public CatExpressionEltElements getCatExpressionEltAccess() {
		return pCatExpressionElt;
	}
	
	public ParserRule getCatExpressionEltRule() {
		return getCatExpressionEltAccess().getRule();
	}
	
	//ListExpression:
	//	op='(' left=SharkExpression ListElts+=ListExpressionElt+ ')' (numType?=NULL strType?=NULL dateType?=NULL
	//	boolType?=NULL)?;
	public ListExpressionElements getListExpressionAccess() {
		return pListExpression;
	}
	
	public ParserRule getListExpressionRule() {
		return getListExpressionAccess().getRule();
	}
	
	//ListExpressionElt:
	//	op=',' right=SharkExpression;
	public ListExpressionEltElements getListExpressionEltAccess() {
		return pListExpressionElt;
	}
	
	public ParserRule getListExpressionEltRule() {
		return getListExpressionEltAccess().getRule();
	}
	
	//RangeExpression ListExpression:
	//	{ListExpression} '(' range=RANGE ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)? | {ListExpression}
	//	=> '(' range=RANGEINF ')' (numType?=NULL strType?=NULL dateType?=NULL boolType?=NULL)?;
	public RangeExpressionElements getRangeExpressionAccess() {
		return pRangeExpression;
	}
	
	public ParserRule getRangeExpressionRule() {
		return getRangeExpressionAccess().getRule();
	}
	
	//enum BinaryOperator:
	//	opOr='or' | opAnd='and' | opAdd='+' | opMin='-' | opMult='*' | opDiv='/'
	//	| opMod='%' | opEq='==' | opGt='>' | opLt='<' | opLte='<=' | opGte='>=' | opPow='^'
	//	| opLike='like' | opDif='!=' | opCat='&' | opIn='in' | opStxt='stxt' | opRound='round';
	public BinaryOperatorElements getBinaryOperatorAccess() {
		return eBinaryOperator;
	}
	
	public EnumRule getBinaryOperatorRule() {
		return getBinaryOperatorAccess().getRule();
	}
	
	//enum UnaryOperator:
	//	opNot='not' | opNeg='-' | strCast='str' | intCast='int' | decCast='dec' | dateCast='date' |
	//	timeCast='time' | opLen='len' | stampCast='stamp';
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return eUnaryOperator;
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}
	
	//TerminalExpression:
	//	{StrValue} value=STR | {IntValue} value=INT | {DecValue} value=DEC | {ChrValue} value=CHR | {CstValue}
	//	value=[Constant|CSTID] | {BoolValue} value=Boolean | {UnsetValue} value=Unset;
	public TerminalExpressionElements getTerminalExpressionAccess() {
		return pTerminalExpression;
	}
	
	public ParserRule getTerminalExpressionRule() {
		return getTerminalExpressionAccess().getRule();
	}
	
	//IdentifierExpression TerminalExpression:
	//	{IdentifierExpression} value=[Attribute|QualifiedName];
	public IdentifierExpressionElements getIdentifierExpressionAccess() {
		return pIdentifierExpression;
	}
	
	public ParserRule getIdentifierExpressionRule() {
		return getIdentifierExpressionAccess().getRule();
	}
	
	//QualifiedName:
	//	(OBJID '.')? ID;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//LineComment:
	//	{Comment} line=CMT EOL;
	public LineCommentElements getLineCommentAccess() {
		return pLineComment;
	}
	
	public ParserRule getLineCommentRule() {
		return getLineCommentAccess().getRule();
	}
	
	//TrailComment:
	//	{Comment} line=CMT;
	public TrailCommentElements getTrailCommentAccess() {
		return pTrailComment;
	}
	
	public ParserRule getTrailCommentRule() {
		return getTrailCommentAccess().getRule();
	}
	
	//enum Unset:
	//	unset;
	public UnsetElements getUnsetAccess() {
		return eUnset;
	}
	
	public EnumRule getUnsetRule() {
		return getUnsetAccess().getRule();
	}
	
	//enum Boolean:
	//	trueCst='true' |
	//	falseCst='false';
	public BooleanElements getBooleanAccess() {
		return eBoolean;
	}
	
	public EnumRule getBooleanRule() {
		return getBooleanAccess().getRule();
	}
	
	//enum DataType:
	//	str | dec | date | time | chr | int | stamp | bits | bool |
	//	unset='\\uFFA0\\uFFA0\\uFFA0';
	public DataTypeElements getDataTypeAccess() {
		return eDataType;
	}
	
	public EnumRule getDataTypeRule() {
		return getDataTypeAccess().getRule();
	}
	
	//terminal BEGIN:
	//	'synthetic:BEGIN';
	public TerminalRule getBEGINRule() {
		return tBEGIN;
	}
	
	//terminal END:
	//	'synthetic:END';
	public TerminalRule getENDRule() {
		return tEND;
	}
	
	//terminal EOL:
	//	'synthetic:EOL';
	public TerminalRule getEOLRule() {
		return tEOL;
	}
	
	//terminal NULL:
	//	'synthetic:NULL';
	public TerminalRule getNULLRule() {
		return tNULL;
	}
	
	//terminal fragment HEX:
	//	'0'..'9' | 'A'..'F' | 'a'..'f';
	public TerminalRule getHEXRule() {
		return tHEX;
	}
	
	//terminal fragment NUM:
	//	'0'..'9'+;
	public TerminalRule getNUMRule() {
		return tNUM;
	}
	
	//terminal fragment UNI:
	//	'u' HEX HEX HEX HEX;
	public TerminalRule getUNIRule() {
		return tUNI;
	}
	
	//terminal fragment ESC:
	//	'\\' ('t' | 'n' | 'r' | '"' | '\\' | UNI);
	public TerminalRule getESCRule() {
		return tESC;
	}
	
	//terminal fragment ASCII:
	//	'!' | '#' | '$' | '%' | '&' | "'" | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0'..'9' | ' ' | ':' | ';' | '<'
	//	| '=' | '>' | '?' | '@' | 'A'..'Z' | '[' | ']' | '^' | '_' | '`' | 'a'..'z' | '{' | '|' | '}' | '~';
	public TerminalRule getASCIIRule() {
		return tASCII;
	}
	
	//terminal fragment NL:
	//	'\r'? '\n';
	public TerminalRule getNLRule() {
		return tNL;
	}
	
	//terminal CHR returns ecore::EChar:
	//	'"' (ESC | ASCII)? '"';
	public TerminalRule getCHRRule() {
		return tCHR;
	}
	
	//terminal STR:
	//	'"' (ESC | ASCII)+ '"';
	public TerminalRule getSTRRule() {
		return tSTR;
	}
	
	//terminal RANGEINF:
	//	NUM '..n';
	public TerminalRule getRANGEINFRule() {
		return tRANGEINF;
	}
	
	//terminal RANGE:
	//	NUM '..' NUM;
	public TerminalRule getRANGERule() {
		return tRANGE;
	}
	
	//terminal CHKID:
	//	'#' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getCHKIDRule() {
		return tCHKID;
	}
	
	//terminal CSTID:
	//	'A'..'Z' ('A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getCSTIDRule() {
		return tCSTID;
	}
	
	//terminal OBJID:
	//	'A'..'Z' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getOBJIDRule() {
		return tOBJID;
	}
	
	//terminal ID:
	//	('a'..'z' | '_' | '~') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal DEC returns ecore::EBigDecimal:
	//	NUM '.' NUM;
	public TerminalRule getDECRule() {
		return tDEC;
	}
	
	//terminal INT returns ecore::EInt:
	//	NUM;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal CONT:
	//	'\\' NL+;
	public TerminalRule getCONTRule() {
		return tCONT;
	}
	
	//terminal IDENT:
	//	NL+ '\t'*;
	public TerminalRule getIDENTRule() {
		return tIDENT;
	}
	
	//terminal CMT:
	//	"'" !('\r' | '\n')*;
	public TerminalRule getCMTRule() {
		return tCMT;
	}
	
	//terminal WS:
	//	' ' | '\t'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER returns ecore::EChar:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}

/*
 * generated by Xtext 2.21.0
 */
package com.shark.lang.tests

import com.google.inject.Inject
import com.shark.lang.dd.DataModelFragment
import javax.inject.Provider
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.InMemoryURIHandler
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

//with a grammar that is EOF sensitive we need to use File Input Stream
@ExtendWith(InjectionExtension)
@InjectWith(DdInjectorProvider)
class DdParsingTest {
	// @Inject ParseHelper<DataModel> parseHelper
	@Inject ValidationTestHelper validationTestHelper
	// @Inject ResourceHelper resourceHelper;
	// @Inject NodeModelUtils modelUtil //nodeUtil is static...
	// @Inject ITokenDefProvider tokenDefProvider;
	// @Inject Lexer lexer;
	@Inject Provider<XtextResourceSet> resourceSetProvider
	
	val handler = new InMemoryURIHandler()


	@Test
	def void testCheckExpressionsPassingCases() {

		val memFile = "inmemory:/testCheckExpressions.dd" -> '''
			int(2,3)  AVERAGE_AGE = (32+4) 		 'to initiate ages
			str(9)  DEFAULT_FIRST_NAME= "@No22Name" 'just for tresting string constants
			date BUG_OF_2000 = "20000101"  'just to test date constants
			date CREATION_OF_BANK = "18700101"  'just to test date constants
			chr  YES = "Y" 'yes constant
			chr  NO = "N"  'no constant
			dec(15,5) MAX_AMOUNT = 3145678190.12345 'max amount
			time MIDNIGHT = "000000" 'to test a time constant 
			stamp MIDNIGHT_STAMP = "20100101.000000.9999" 'to test a time constant 
			chr[2] GENDERS = ("M","F") 'domain values for gender
			str(3)[5] ALLOWED_ISO_3_CCY = ("eur","USD","GPB","JPY","RMB") 'domain values for currencies 
			bits PLAIN = "00000" 'this is a joke...
			bool TRUE = true 'for testinrg
			date[3] TARGET_HOLIDAYS = ("20000101","18700101","17890101") 'bank holidays for europe target2 all put in year 2000
			time[3] CUTOFF_TIMES = ("120000","163000","193059") 'time of sepa cutoffs
			stamp[2] MILLENIUM_BUG = ("20000101.000000.0000","20000101.000000.0000") 'the time after which all should have gone mad
			
			'this is the entity description
			'it can have several lines
			'to decribe the entity person below
			'a Person can be a customer or a related party or an employee 
			Person:
				'extra attribute description for attribute id that follows
				'it can have as many lines as we want, while the trailing comment at the 
				'end of the line is a single line comment
				int(10)  id  pk 'the internal identifier of the Person
			
				'See here an example of a line continuation \ which is the only way to split a statement into several line
				str(100) name \
										="Chang" 'name of the person which I defaulted to one for the sake of the example
				str(100) prenom = DEFAULT_FIRST_NAME 'first name of the customer
				chr	     gender = "M" 'the gendre either M or F
			
				date     dateOfBirth = BUG_OF_2000 'the date of birth is initialized for generation Millenial 
				time     timeOfBirth = MIDNIGHT 'init at midnight
				str(2)   countryOfBirth_iso2 = "CN" 'initialized to the most common country in the world :-)
			
				str(5)   postalCode = "92500" 'code desc
				'forbidden physical description data :-)
				bits(5)  physical_description = "11010" 'blue eyes (0|1) dark hair (0|1) dark skin (0|1) height>1,75 (0|1) fat (0|1)
			
			'a customer can be a person or a company
			Customer:
				int(10) 	id  pk 'the internal identifier of the Customer 
				(0..1) isPerson (1..1) Person 'a Cutomer has to be a Person (abstracting the notion of company for the example) but a Person might not be
				(1..n) hasAccounts (0..n) Account 'should move to a 1-n relationship because a customer has at least one account
			
			'banking account, can be of many types (term, savings, current, overdraft...)
			Account:
				int(11) 			num     pk   ! 'the internal acount number 
				dec(13,7) 		balance 'balance os the account with a large enough precision for all type of currency
				str(100) 					description ! 'open description of the account from a customer standpoint, mandatory with !
				date openDate = "20120101" 'opening date of the account
				time openTime = "141853" 'opening time on the client side 
				stamp openTimeStamp = "20120101.141857.1234"  'timestamp at write time on the DB
				bits flags 'to store shit in ity
			
			'default checks done all the time
			'add a validation that it cannot crossref other entities unless there is a 1-1 relationship
			#Account:
				'test the account opening date validity: it cannot be less than the bank historical creation in 1870 and limite to next 200 years
				test1 (((Account.openDate>=CREATION_OF_BANK) or (Account.openDate<=date("22000101"))) and ((7==8)==true))
				'test date cast
				test2 ((Account.num>=5) or (0<=8) or (Account.openDate==date("")) or ((1+6+Account.balance)>=9))
				'mandatory doc on tests
				test3 (((1+2+4+(5*5*6)+(5/6))==0) or ((10/3) in (1,2)))
				'mandatory doc
				test4 (("" stxt (1,2))=="") 
			
			'default intrinsic checks for a person entity
			#Person:
				'test date on constants
				test1 ((len(Person.name)>=5) or (0<=8) or (Person.dateOfBirth==date(DEFAULT_FIRST_NAME)) or ((1+6+Person.id)<9))
				'test2
				test2 ((1 in (1..4)) and (("ABC" in "DBCDABC")==4))
				'test
				test3 (("A" in "ABCDEF")==0) 
				'test
				test4 (Person.gender in GENDERS)
				'test
				test5 ("hello" in ("hello","bonjour","guten morgen")) 
				'test
				test6 (DEFAULT_FIRST_NAME like str(123))
			
			'All cross checks for persons and accounts
			#Accounts_Person:
				'test
				test1 ((len(Person.name)>=5) or (0<=8) or (Person.dateOfBirth==CREATION_OF_BANK) or ((1+6+Account.balance)<9))
				'test
				test2 true
				'test
				test3 ((1+2+3+4+(5*5)+(5*6))==6)
		'''

		val model = testMemoryFile(memFile)
		println(NodeModelUtils.compactDump(NodeModelUtils.getNode(model), true))
		
	}

	def DataModelFragment testMemoryFile(Pair<String, String> fileDesc) {
		val inMemFile = handler.getInMemoryFile(URI.createURI(fileDesc.key))
		inMemFile.contents = fileDesc.value.bytes
		inMemFile.exists = true
		val resourceSet = resourceSetProvider.get
		resourceSet.URIConverter.URIHandlers.add(0, handler)
		val resource = resourceSet.getResource(URI.createURI(fileDesc.key), true)
		resource.load(null)
		val model = resource.contents.head as DataModelFragment
		validationTestHelper.assertNoIssues(model)
		if (resource.loaded) {
			val errors = resource.errors
			Assertions.assertTrue(errors.isEmpty, '''Errors: «errors.join(", ")»''')
		}
		return model
	}

}
